'use strict';

const utils = require('@typescript-eslint/utils');
const path = require('node:path');

function _interopNamespaceCompat(e) {
	if (e && typeof e === 'object' && 'default' in e) return e;
	const n = Object.create(null);
	if (e) {
		for (const k in e) {
			n[k] = e[k];
		}
	}
	n.default = e;
	return n;
}

const path__namespace = /*#__PURE__*/_interopNamespaceCompat(path);

const createEslintRule = utils.ESLintUtils.RuleCreator((ruleName) => `https://github.com/veritem/eslint-plugin-vitest/blob/main/docs/rules/${ruleName}.md`);
const joinNames = (a, b) => a && b ? `${a}.${b}` : null;
const isFunction = (node) => node.type === utils.AST_NODE_TYPES.FunctionExpression || node.type === utils.AST_NODE_TYPES.ArrowFunctionExpression;
function getNodeName(node) {
  if (isSupportedAccessor(node))
    return getAccessorValue(node);
  switch (node.type) {
    case utils.AST_NODE_TYPES.TaggedTemplateExpression:
      return getNodeName(node.tag);
    case utils.AST_NODE_TYPES.MemberExpression:
      return joinNames(getNodeName(node.object), getNodeName(node.property));
    case utils.AST_NODE_TYPES.NewExpression:
    case utils.AST_NODE_TYPES.CallExpression:
      return getNodeName(node.callee);
  }
  return null;
}
const isSupportedAccessor = (node, value) => {
  return isIdentifier(node, value) || isStringNode(node, value);
};
const isIdentifier = (node, name) => {
  return node.type === utils.AST_NODE_TYPES.Identifier && (name === void 0 || node.name === name);
};
const isTemplateLiteral = (node, value) => {
  return node.type === utils.AST_NODE_TYPES.TemplateLiteral && node.quasis.length === 1 && (value === void 0 || node.quasis[0].value.raw === value);
};
const isStringLiteral = (node, value) => node.type === utils.AST_NODE_TYPES.Literal && typeof node.value === "string" && (value === void 0 || node.value === value);
const isStringNode = (node, specifics) => isStringLiteral(node, specifics) || isTemplateLiteral(node, specifics);
const getAccessorValue = (accessor) => accessor.type === utils.AST_NODE_TYPES.Identifier ? accessor.name : getStringValue(accessor);
const getStringValue = (node) => node?.type === utils.AST_NODE_TYPES.TemplateLiteral ? node.quasis[0].value.raw : node?.value;
const replaceAccessorFixer = (fixer, node, text) => {
  return fixer.replaceText(
    node,
    node.type === utils.AST_NODE_TYPES.Identifier ? text : `'${text}'`
  );
};
const removeExtraArgumentsFixer = (fixer, context, func, from) => {
  const firstArg = func.arguments[from];
  const lastArg = func.arguments[func.arguments.length - 1];
  const sourceCode = context.getSourceCode();
  let tokenAfterLastParam = sourceCode.getTokenAfter(lastArg);
  if (tokenAfterLastParam.value === ",")
    tokenAfterLastParam = sourceCode.getTokenAfter(tokenAfterLastParam);
  return fixer.removeRange([firstArg.range[0], tokenAfterLastParam.range[0]]);
};
const isParsedInstanceOfMatcherCall = (expectFnCall, classArg) => {
  return getAccessorValue(expectFnCall.matcher) === "toBeInstanceOf" && expectFnCall.args.length === 1 && isSupportedAccessor(expectFnCall.args[0], classArg);
};

var DescribeAlias = /* @__PURE__ */ ((DescribeAlias2) => {
  DescribeAlias2["describe"] = "describe";
  DescribeAlias2["fdescribe"] = "fdescribe";
  DescribeAlias2["xdescribe"] = "xdescribe";
  return DescribeAlias2;
})(DescribeAlias || {});
var TestCaseName = /* @__PURE__ */ ((TestCaseName2) => {
  TestCaseName2["fit"] = "fit";
  TestCaseName2["it"] = "it";
  TestCaseName2["test"] = "test";
  TestCaseName2["xit"] = "xit";
  TestCaseName2["xtest"] = "xtest";
  return TestCaseName2;
})(TestCaseName || {});
var HookName = /* @__PURE__ */ ((HookName2) => {
  HookName2["beforeAll"] = "beforeAll";
  HookName2["beforeEach"] = "beforeEach";
  HookName2["afterAll"] = "afterAll";
  HookName2["afterEach"] = "afterEach";
  return HookName2;
})(HookName || {});
var ModifierName = /* @__PURE__ */ ((ModifierName2) => {
  ModifierName2["not"] = "not";
  ModifierName2["rejects"] = "rejects";
  ModifierName2["resolves"] = "resolves";
  return ModifierName2;
})(ModifierName || {});
var EqualityMatcher = /* @__PURE__ */ ((EqualityMatcher2) => {
  EqualityMatcher2["toBe"] = "toBe";
  EqualityMatcher2["toEqual"] = "toEqual";
  EqualityMatcher2["toStrictEqual"] = "toStrictEqual";
  return EqualityMatcher2;
})(EqualityMatcher || {});

const ValidVitestFnCallChains = [
  "afterAll",
  "afterEach",
  "beforeAll",
  "beforeEach",
  "describe",
  "describe.each",
  "describe.only",
  "describe.only.each",
  "describe.skip",
  "describe.skip.each",
  "fdescribe",
  "fdescribe.each",
  "xdescribe",
  "xdescribe.each",
  "it",
  "it.concurrent",
  "it.concurrent.each",
  "it.concurrent.only.each",
  "it.concurrent.skip.each",
  "it.each",
  "it.failing",
  "it.only",
  "it.only.each",
  "it.only.failing",
  "it.skip",
  "it.skip.each",
  "it.skip.failing",
  "it.todo",
  "fit",
  "fit.each",
  "fit.failing",
  "xit",
  "xit.each",
  "xit.failing",
  "test",
  "test.concurrent",
  "test.concurrent.each",
  "test.concurrent.only.each",
  "test.concurrent.skip.each",
  "test.each",
  "test.failing",
  "test.only",
  "test.only.each",
  "test.only.failing",
  "test.skip",
  "test.skip.each",
  "test.skip.failing",
  "test.todo",
  "xtest",
  "xtest.each",
  "xtest.failing"
];
const isTypeOfVitestFnCall = (node, context, types) => {
  const vitestFnCall = parseVitestFnCall(node, context);
  return vitestFnCall !== null && types.includes(vitestFnCall.type);
};
const parseVitestFnCall = (node, context) => {
  const vitestFnCall = parseVitestFnCallWithReason(node, context);
  if (typeof vitestFnCall === "string")
    return null;
  return vitestFnCall;
};
const parseVitestFnCallCache = /* @__PURE__ */ new WeakMap();
const parseVitestFnCallWithReason = (node, context) => {
  let parsedVistestFnCall = parseVitestFnCallCache.get(node);
  if (parsedVistestFnCall)
    return parsedVistestFnCall;
  parsedVistestFnCall = parseVistestFnCallWithReasonInner(node, context);
  parseVitestFnCallCache.set(node, parsedVistestFnCall);
  return parsedVistestFnCall;
};
const determineVitestFnType = (name) => {
  if (name === "expect")
    return "expect";
  if (name === "expectTypeOf")
    return "expectTypeOf";
  if (name === "vi")
    return "vi";
  if (DescribeAlias.hasOwnProperty(name))
    return "describe";
  if (TestCaseName.hasOwnProperty(name))
    return "test";
  if (HookName.hasOwnProperty(name))
    return "hook";
  return "unknown";
};
const findModifiersAndMatcher = (members) => {
  const modifiers = [];
  for (const member of members) {
    if (member.parent?.type === utils.AST_NODE_TYPES.MemberExpression && member.parent.parent?.type === utils.AST_NODE_TYPES.CallExpression) {
      return {
        matcher: member,
        args: member.parent.parent.arguments,
        modifiers
      };
    }
    const name = getAccessorValue(member);
    if (modifiers.length === 0) {
      if (!ModifierName.hasOwnProperty(name))
        return "modifier-unknown";
    } else if (modifiers.length === 1) {
      if (name !== ModifierName.not)
        return "modifier-unknown";
      const firstModifier = getAccessorValue(modifiers[0]);
      if (firstModifier !== ModifierName.resolves && firstModifier !== ModifierName.rejects)
        return "modifier-unknown";
    } else {
      return "modifier-unknown";
    }
    modifiers.push(member);
  }
  return "matcher-not-found";
};
const parseVitestExpectCall = (typelessParsedVitestFnCall, type) => {
  const modifiersMatcher = findModifiersAndMatcher(typelessParsedVitestFnCall.members);
  if (typeof modifiersMatcher === "string")
    return modifiersMatcher;
  return {
    ...typelessParsedVitestFnCall,
    type,
    ...modifiersMatcher
  };
};
const findTopMostCallExpression = (node) => {
  let topMostCallExpression = node;
  let { parent } = node;
  while (parent) {
    if (parent.type === utils.AST_NODE_TYPES.CallExpression) {
      topMostCallExpression = parent;
      parent = parent.parent;
      continue;
    }
    if (parent.type !== utils.AST_NODE_TYPES.MemberExpression)
      break;
    parent = parent.parent;
  }
  return topMostCallExpression;
};
const parseVistestFnCallWithReasonInner = (node, context) => {
  const chain = getNodeChain(node);
  if (!chain?.length)
    return null;
  const [first, ...rest] = chain;
  const lastLink = getAccessorValue(chain[chain.length - 1]);
  if (lastLink === "each") {
    if (node.callee.type !== utils.AST_NODE_TYPES.CallExpression && node.callee.type !== utils.AST_NODE_TYPES.TaggedTemplateExpression)
      return null;
  }
  if (node.callee.type === utils.AST_NODE_TYPES.TaggedTemplateExpression && lastLink !== "each")
    return null;
  const resolved = resolveVitestFn(context, getAccessorValue(first));
  if (!resolved)
    return null;
  const name = resolved.original ?? resolved.local;
  const links = [name, ...rest.map(getAccessorValue)];
  if (name !== "vi" && name !== "expect" && name !== "expectTypeOf" && !ValidVitestFnCallChains.includes(links.join(".")))
    return null;
  const parsedVitestFnCall = {
    name,
    head: { ...resolved, node: first },
    members: rest
  };
  const type = determineVitestFnType(name);
  if (type === "expect" || type === "expectTypeOf") {
    const result = parseVitestExpectCall(parsedVitestFnCall, type);
    if (typeof result === "string" && findTopMostCallExpression(node) !== node)
      return null;
    if (result === "matcher-not-found") {
      if (node.parent?.type === utils.AST_NODE_TYPES.MemberExpression)
        return "matcher-not-called";
    }
    return result;
  }
  if (chain.slice(0, chain.length - 1).some((node2) => node2.parent?.type !== utils.AST_NODE_TYPES.MemberExpression))
    return null;
  if (node.parent?.type === utils.AST_NODE_TYPES.CallExpression || node.parent?.type === utils.AST_NODE_TYPES.MemberExpression)
    return null;
  return { ...parsedVitestFnCall, type };
};
const joinChains = (a, b) => a && b ? [...a, ...b] : null;
function getNodeChain(node) {
  if (isSupportedAccessor(node))
    return [node];
  switch (node.type) {
    case utils.AST_NODE_TYPES.TaggedTemplateExpression:
      return getNodeChain(node.tag);
    case utils.AST_NODE_TYPES.MemberExpression:
      return joinChains(getNodeChain(node.object), getNodeChain(node.property));
    case utils.AST_NODE_TYPES.CallExpression:
      return getNodeChain(node.callee);
  }
  return null;
}
const resolveVitestFn = (context, identifier) => {
  const maybeImport = resolveScope(context.getScope(), identifier);
  if (maybeImport === "local")
    return null;
  if (maybeImport) {
    if (maybeImport.source === "vitest") {
      return {
        original: maybeImport.imported,
        local: maybeImport.local,
        type: "import"
      };
    }
    return null;
  }
  return {
    original: resolvePossibleAliasedGlobal(identifier, context),
    local: identifier,
    type: "global"
  };
};
const resolvePossibleAliasedGlobal = (global, context) => {
  const globalAliases = context.settings.vitest?.globalAliases ?? {};
  const alias = Object.entries(globalAliases).find(([_, aliases]) => aliases.includes(global));
  if (alias)
    return alias[0];
  return null;
};
const resolveScope = (scope, identifier) => {
  let currentScope = scope;
  while (currentScope !== null) {
    const ref = currentScope.set.get(identifier);
    if (ref && ref.defs.length > 0) {
      const def = ref.defs[ref.defs.length - 1];
      const importDetails = describePossibleImportDef(def);
      if (importDetails?.local === identifier)
        return importDetails;
      return "local";
    }
    currentScope = currentScope.upper;
  }
  return null;
};
const findImportSourceNode = (node) => {
  if (node.type === utils.AST_NODE_TYPES.AwaitExpression) {
    if (node.argument.type === utils.AST_NODE_TYPES.ImportExpression)
      return node.argument.source;
    return null;
  }
  if (node.type === utils.AST_NODE_TYPES.CallExpression && isIdentifier(node.callee, "require"))
    return node.arguments[0] ?? null;
  return null;
};
const describeImportDefAsImport = (def) => {
  if (def.parent.type === utils.AST_NODE_TYPES.TSImportEqualsDeclaration)
    return null;
  if (def.node.type !== utils.AST_NODE_TYPES.ImportSpecifier)
    return null;
  if (def.parent.importKind === "type")
    return null;
  return {
    source: def.parent.source.value,
    imported: def.node.imported.name,
    local: def.node.local.name
  };
};
const describePossibleImportDef = (def) => {
  if (def.type === "Variable")
    return describeVariableDefAsImport(def);
  if (def.type === "ImportBinding")
    return describeImportDefAsImport(def);
  return null;
};
const describeVariableDefAsImport = (def) => {
  if (!def.node.init)
    return null;
  const sourceNode = findImportSourceNode(def.node.init);
  if (!sourceNode || !isStringNode(sourceNode))
    return null;
  if (def.name.parent?.type !== utils.AST_NODE_TYPES.Property)
    return null;
  if (!isSupportedAccessor(def.name.parent.key))
    return null;
  return {
    source: getStringValue(sourceNode),
    imported: getAccessorValue(def.name.parent.key),
    local: def.name.name
  };
};
const getTestCallExpressionsFromDeclaredVariables = (declaredVariables, context) => {
  return declaredVariables.reduce(
    (acc, { references }) => acc.concat(
      references.map(({ identifier }) => identifier.parent).filter(
        (node) => node?.type === utils.AST_NODE_TYPES.CallExpression && isTypeOfVitestFnCall(node, context, ["test"])
      )
    ),
    []
  );
};
const getFirstMatcherArg = (expectFnCall) => {
  const [firstArg] = expectFnCall.args;
  if (firstArg.type === utils.AST_NODE_TYPES.SpreadElement)
    return firstArg;
  return followTypeAssertionChain(firstArg);
};
const isTypeCastExpression = (node) => node.type === utils.AST_NODE_TYPES.TSAsExpression || node.type === utils.AST_NODE_TYPES.TSTypeAssertion;
const followTypeAssertionChain = (expression) => isTypeCastExpression(expression) ? followTypeAssertionChain(expression.expression) : expression;

const RULE_NAME$M = "prefer-lowercase-title";
const hasStringAsFirstArgument = (node) => node.arguments[0] && isStringNode(node.arguments[0]);
const populateIgnores = (ignore) => {
  const ignores = [];
  if (ignore.includes(DescribeAlias.describe))
    ignores.push(...Object.keys(DescribeAlias));
  if (ignore.includes(TestCaseName.test)) {
    ignores.push(
      ...Object.keys(TestCaseName).filter((k) => k.endsWith(TestCaseName.test))
    );
  }
  if (ignore.includes(TestCaseName.it)) {
    ignores.push(
      ...Object.keys(TestCaseName).filter((k) => k.endsWith(TestCaseName.it))
    );
  }
  return ignores;
};
const lowerCaseTitle = createEslintRule({
  name: RULE_NAME$M,
  meta: {
    type: "problem",
    docs: {
      description: "Enforce lowercase titles",
      recommended: "warn"
    },
    fixable: "code",
    messages: {
      lowerCaseTitle: "`{{ method }}`s should begin with lowercase"
    },
    schema: [
      {
        type: "object",
        properties: {
          ignore: {
            type: "array",
            items: {
              enum: [
                DescribeAlias.describe,
                TestCaseName.test,
                TestCaseName.it
              ]
            },
            additionalProperties: false
          },
          allowedPrefixes: {
            type: "array",
            items: { type: "string" },
            additionalItems: false
          },
          ignoreTopLevelDescribe: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [
    { ignore: [], allowedPrefixes: [], ignoreTopLevelDescribe: false }
  ],
  create: (context, [{ ignore = [], allowedPrefixes = [], ignoreTopLevelDescribe = [] }]) => {
    const ignores = populateIgnores(ignore);
    let numberOfDescribeBlocks = 0;
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!vitestFnCall || !hasStringAsFirstArgument)
          return;
        if (vitestFnCall?.type === "describe") {
          numberOfDescribeBlocks++;
          if (ignoreTopLevelDescribe && numberOfDescribeBlocks === 1)
            return;
        } else if (vitestFnCall?.type !== "test") {
          return;
        }
        const [firstArgument] = node.arguments;
        const description = getStringValue(firstArgument);
        if (typeof description !== "string")
          return;
        if (allowedPrefixes.some((prefix) => description.startsWith(prefix)))
          return;
        const firstCharacter = description.charAt(0);
        if (!firstCharacter || firstCharacter === firstCharacter.toLowerCase() || ignores.includes(vitestFnCall.name))
          return;
        context.report({
          messageId: "lowerCaseTitle",
          node: node.arguments[0],
          data: {
            method: vitestFnCall.name
          },
          fix: (fixer) => {
            const description2 = getStringValue(firstArgument);
            const rangeIgnoreQuotes = [
              firstArgument.range[0] + 1,
              firstArgument.range[1] - 1
            ];
            const newDescription = description2.substring(0, 1).toLowerCase() + description2.substring(1);
            return [fixer.replaceTextRange(rangeIgnoreQuotes, newDescription)];
          }
        });
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["describe"]))
          numberOfDescribeBlocks--;
      }
    };
  }
});

const RULE_NAME$L = "max-nested-describe";
const maxNestedDescribe = createEslintRule({
  name: RULE_NAME$L,
  meta: {
    type: "problem",
    docs: {
      description: "Nested describe block should be less than set max value or default value",
      recommended: "error"
    },
    schema: [
      {
        type: "object",
        properties: {
          max: {
            type: "number"
          }
        },
        additionalProperties: false
      }
    ],
    messages: {
      maxNestedDescribe: "Nested describe block should be less than set max value."
    }
  },
  defaultOptions: [
    {
      max: 5
    }
  ],
  create(context, [{ max }]) {
    const stack = [];
    function pushStack(node) {
      if (node.parent?.type !== "CallExpression")
        return;
      if (node.parent.callee.type !== "Identifier" || node.parent.callee.name !== "describe")
        return;
      stack.push(0);
      if (stack.length > max) {
        context.report({
          node: node.parent,
          messageId: "maxNestedDescribe"
        });
      }
    }
    function popStack(node) {
      if (node.parent?.type !== "CallExpression")
        return;
      if (node.parent.callee.type !== "Identifier" || node.parent.callee.name !== "describe")
        return;
      stack.pop();
    }
    return {
      FunctionExpression: pushStack,
      "FunctionExpression:exit": popStack,
      ArrowFunctionExpression: pushStack,
      "ArrowFunctionExpression:exit": popStack
    };
  }
});

const RULE_NAME$K = "no-identical-title";
const newDescribeContext = () => ({
  describeTitles: [],
  testTitles: []
});
const noIdenticalTitle = createEslintRule({
  name: RULE_NAME$K,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow identical titles",
      recommended: "strict"
    },
    fixable: "code",
    schema: [],
    messages: {
      multipleTestTitle: "Test is used multiple times in the same describe block",
      multipleDescribeTitle: "Describe is used multiple times in the same describe block"
    }
  },
  defaultOptions: [],
  create(context) {
    const stack = [newDescribeContext()];
    return {
      CallExpression(node) {
        const currentStack = stack[stack.length - 1];
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!vitestFnCall)
          return;
        if (vitestFnCall.name === "describe")
          stack.push(newDescribeContext());
        if (vitestFnCall.members.find((s) => isSupportedAccessor(s, "each")))
          return;
        const [argument] = node.arguments;
        if (!argument || !isStringNode(argument))
          return;
        const title = getStringValue(argument);
        if (vitestFnCall.type === "test") {
          if (currentStack.testTitles.includes(title)) {
            context.report({
              node,
              messageId: "multipleTestTitle"
            });
          }
          currentStack.testTitles.push(title);
        }
        if (vitestFnCall.type !== "describe")
          return;
        if (currentStack?.describeTitles.includes(title)) {
          context.report({
            node,
            messageId: "multipleDescribeTitle"
          });
        }
        currentStack?.describeTitles.push(title);
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["describe"]))
          stack.pop();
      }
    };
  }
});

const RULE_NAME$J = "no-focused-tests";
const noFocusedTests = createEslintRule({
  name: RULE_NAME$J,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow focused tests",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      noFocusedTests: "Focused tests are not allowed."
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      ExpressionStatement(node) {
        if (node.expression.type === "CallExpression") {
          const { callee } = node.expression;
          if (callee.type === "MemberExpression" && callee.object.type === "Identifier" && (callee.object.name === "it" || callee.object.name === "describe") && callee.property.type === "Identifier" && callee.property.name === "only") {
            context.report({
              node: callee.property,
              messageId: "noFocusedTests"
            });
          }
        }
      }
    };
  }
});

const RULE_NAME$I = "no-conditional-tests";
const noConditionalTest = createEslintRule({
  name: RULE_NAME$I,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow conditional tests",
      recommended: false
    },
    schema: [],
    messages: {
      noConditionalTests: "Avoid using conditionals in a test."
    }
  },
  defaultOptions: [],
  create(context) {
    let isInTestBlock = false;
    function checkIfItsUnderTestOrItBlock(node) {
      if (node.type === "CallExpression" && node.callee.type === "Identifier" && (node.callee.name === "it" || node.callee.name === "test"))
        return true;
    }
    function reportConditional(node) {
      if (isInTestBlock) {
        context.report({
          node,
          messageId: "noConditionalTests"
        });
      }
    }
    return {
      CallExpression: function(node) {
        if (checkIfItsUnderTestOrItBlock(node))
          isInTestBlock = true;
      },
      "CallExpression:exit": function(node) {
        if (checkIfItsUnderTestOrItBlock(node))
          isInTestBlock = false;
      },
      IfStatement: reportConditional,
      SwitchStatement: reportConditional,
      LogicalExpression: reportConditional,
      ConditionalExpression: reportConditional
    };
  }
});

const RULE_NAME$H = "expect-expect";
function matchesAssertFunctionName(nodeName, patterns) {
  return patterns.some(
    (p) => new RegExp(
      `^${p.split(".").map((x) => {
        if (x === "**")
          return "[a-z\\d\\.]*";
        return x.replace(/\*/gu, "[a-z\\d]*");
      }).join("\\.")}(\\.|$)`,
      "ui"
    ).test(nodeName)
  );
}
const expectExpect = createEslintRule({
  name: RULE_NAME$H,
  meta: {
    type: "suggestion",
    docs: {
      description: "Enforce having expectation in test body",
      recommended: "strict"
    },
    schema: [],
    messages: {
      expectedExpect: "Use 'expect' in test body"
    }
  },
  defaultOptions: [],
  create: (context) => {
    const unchecked = [];
    function checkCallExpressionUsed(nodes) {
      for (const node of nodes) {
        const index = node.type === utils.AST_NODE_TYPES.CallExpression ? unchecked.indexOf(node) : -1;
        if (node.type === utils.AST_NODE_TYPES.FunctionDeclaration) {
          const declaredVariables = context.getDeclaredVariables(node);
          const textCallExpression = getTestCallExpressionsFromDeclaredVariables(declaredVariables, context);
          checkCallExpressionUsed(textCallExpression);
        }
        if (index !== -1) {
          unchecked.splice(index, 1);
          break;
        }
      }
    }
    return {
      CallExpression(node) {
        const name = getNodeName(node) ?? "";
        if (isTypeOfVitestFnCall(node, context, ["test"])) {
          if (node.callee.type === utils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.callee.property, "todo"))
            return;
          unchecked.push(node);
        } else if (matchesAssertFunctionName(name, ["expect"])) {
          checkCallExpressionUsed(context.getAncestors());
        }
      },
      "Program:exit"() {
        unchecked.forEach((node) => context.report({ node, messageId: "expectedExpect" }));
      }
    };
  }
});

const RULE_NAME$G = "consistent-test-it";
const buildFixer = (callee, nodeName, preferredTestKeyword) => (fixer) => [
  fixer.replaceText(
    callee.type === utils.AST_NODE_TYPES.MemberExpression ? callee.object : callee,
    getPreferredNodeName(nodeName, preferredTestKeyword)
  )
];
function getPreferredNodeName(nodeName, preferredTestKeyword) {
  if (nodeName === TestCaseName.fit)
    return "test.only";
  return nodeName.startsWith("f") || nodeName.startsWith("x") ? nodeName.charAt(0) + preferredTestKeyword : preferredTestKeyword;
}
function getOppositeTestKeyword(test) {
  if (test === TestCaseName.test)
    return TestCaseName.it;
  return TestCaseName.test;
}
const consistentTestIt = createEslintRule({
  name: RULE_NAME$G,
  meta: {
    type: "suggestion",
    fixable: "code",
    docs: {
      description: "Prefer test or it but not both",
      recommended: "warn"
    },
    messages: {
      consistentMethod: "Prefer using {{ testFnKeyWork }} instead of {{ oppositeTestKeyword }}",
      consistentMethodWithinDescribe: "Prefer using {{ testKeywordWithinDescribe }} instead of {{ oppositeTestKeyword }} within describe"
    },
    schema: [
      {
        type: "object",
        properties: {
          fn: {
            enum: [TestCaseName.test, TestCaseName.it]
          },
          withinDescribe: {
            enum: [TestCaseName.test, TestCaseName.it]
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{ fn: TestCaseName.test, withinDescribe: TestCaseName.it }],
  create(context) {
    const config = context.options[0] ?? {};
    const testFnKeyWork = config.fn || TestCaseName.test;
    const testKeywordWithinDescribe = config?.withinDescribe || config?.fn || TestCaseName?.it;
    let describeNestingLevel = 0;
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!vitestFnCall)
          return;
        if (vitestFnCall.type === "describe") {
          describeNestingLevel++;
          return;
        }
        const funcNode = node.callee.type === utils.AST_NODE_TYPES.TaggedTemplateExpression ? node.callee.tag : node.callee.type === utils.AST_NODE_TYPES.CallExpression ? node.callee.callee : node.callee;
        if (vitestFnCall.type === "test" && describeNestingLevel === 0 && !vitestFnCall.name.endsWith(testFnKeyWork)) {
          const oppositeTestKeyword = getOppositeTestKeyword(testFnKeyWork);
          context.report({
            node: node.callee,
            data: { testFnKeyWork, oppositeTestKeyword },
            messageId: "consistentMethod",
            fix: buildFixer(funcNode, vitestFnCall.name, testFnKeyWork)
          });
        } else if (vitestFnCall.type === "test" && describeNestingLevel > 0 && !vitestFnCall.name.endsWith(testKeywordWithinDescribe)) {
          const oppositeTestKeyword = getOppositeTestKeyword(testKeywordWithinDescribe);
          context.report({
            messageId: "consistentMethodWithinDescribe",
            node: node.callee,
            data: { testKeywordWithinDescribe, oppositeTestKeyword },
            fix: buildFixer(funcNode, vitestFnCall.name, testKeywordWithinDescribe)
          });
        }
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["describe"]))
          describeNestingLevel--;
      }
    };
  }
});

const RULE_NAME$F = "prefer-to-be";
const isNullLiteral = (node) => node.type === utils.AST_NODE_TYPES.Literal && node.value === null;
const isNullEqualityMatcher = (expectFnCall) => isNullLiteral(getFirstMatcherArg(expectFnCall));
const isFirstArgumentIdentifier = (expectFnCall, name) => isIdentifier(getFirstMatcherArg(expectFnCall), name);
const isFloat = (v) => Math.floor(v) !== Math.ceil(v);
const shouldUseToBe = (expectFnCall) => {
  let firstArg = getFirstMatcherArg(expectFnCall);
  if (firstArg.type === utils.AST_NODE_TYPES.Literal && typeof firstArg.value === "number" && isFloat(firstArg.value))
    return false;
  if (firstArg.type === utils.AST_NODE_TYPES.UnaryExpression && firstArg.operator === "-")
    firstArg = firstArg.argument;
  if (firstArg.type === utils.AST_NODE_TYPES.Literal) {
    return !("regex" in firstArg);
  }
  return firstArg.type === utils.AST_NODE_TYPES.TemplateLiteral;
};
const reportPreferToBe = (context, whatToBe, expectFnCall, func, modifierNode) => {
  context.report({
    messageId: `useToBe${whatToBe}`,
    fix(fixer) {
      const fixes = [
        replaceAccessorFixer(fixer, expectFnCall.matcher, `toBe${whatToBe}`)
      ];
      if (expectFnCall.args?.length && whatToBe !== "")
        fixes.push(removeExtraArgumentsFixer(fixer, context, func, 0));
      if (modifierNode) {
        fixes.push(
          fixer.removeRange([modifierNode.range[0] - 1, modifierNode.range[1]])
        );
      }
      return fixes;
    },
    node: expectFnCall.matcher
  });
};
const preferToBe = createEslintRule({
  name: RULE_NAME$F,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using toBe()",
      recommended: "strict"
    },
    schema: [],
    fixable: "code",
    messages: {
      useToBe: "Use `toBe` instead",
      useToBeUndefined: "Use `toBeUndefined()` instead",
      useToBeDefined: "Use `toBeDefined()` instead",
      useToBeNull: "Use `toBeNull()` instead",
      useToBeNaN: "Use `toBeNaN()` instead"
    }
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        const matcherName = getAccessorValue(vitestFnCall.matcher);
        const notModifier = vitestFnCall.modifiers.find((node2) => getAccessorValue(node2) === "not");
        if (notModifier && ["toBeUndefined", "toBeDefined"].includes(matcherName)) {
          reportPreferToBe(context, matcherName === "toBeDefined" ? "Undefined" : "Defined", vitestFnCall, node, notModifier);
          return;
        }
        if (!EqualityMatcher.hasOwnProperty(matcherName) || vitestFnCall.args.length === 0)
          return;
        if (isNullEqualityMatcher(vitestFnCall)) {
          reportPreferToBe(context, "Null", vitestFnCall, node);
          return;
        }
        if (isFirstArgumentIdentifier(vitestFnCall, "undefined")) {
          const name = notModifier ? "Defined" : "Undefined";
          reportPreferToBe(context, name, vitestFnCall, node);
          return;
        }
        if (isFirstArgumentIdentifier(vitestFnCall, "NaN")) {
          reportPreferToBe(context, "NaN", vitestFnCall, node);
          return;
        }
        if (shouldUseToBe(vitestFnCall) && matcherName !== EqualityMatcher.toBe)
          reportPreferToBe(context, "", vitestFnCall, node);
      }
    };
  }
});

const RULE_NAME$E = "no-hooks";
const noHooks = createEslintRule({
  name: RULE_NAME$E,
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow setup and teardown hooks",
      recommended: false
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          contains: ["beforeAll", "beforeEach", "afterAll", "afterEach"]
        }
      },
      additionalProperties: false
    }],
    messages: {
      unexpectedHook: "Unexpected '{{ hookName }}' hook"
    }
  },
  defaultOptions: [{ allow: [] }],
  create(context, [{ allow = [] }]) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type === "hook" && !allow.includes(vitestFnCall.name)) {
          context.report({
            node,
            messageId: "unexpectedHook",
            data: { hookName: vitestFnCall.name }
          });
        }
      }
    };
  }
});

const RULE_NAME$D = "no-restricted-vi-methods";
const noRestrictedViMethods = createEslintRule({
  name: RULE_NAME$D,
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow specific `vi.` methods",
      recommended: false
    },
    schema: [{
      type: "object",
      additionalProperties: { type: ["string", "null"] }
    }],
    messages: {
      restrictedViMethod: "Use of `{{ restriction }}` is disallowed",
      restrictedViMethodWithMessage: "{{ message }}"
    }
  },
  defaultOptions: [{}],
  create(context, [restrictedMethods]) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "vi" || vitestFnCall.members.length === 0)
          return;
        const method = getAccessorValue(vitestFnCall.members[0]);
        if (method in restrictedMethods) {
          const message = restrictedMethods[method];
          context.report({
            messageId: message ? "restrictedViMethodWithMessage" : "restrictedViMethod",
            data: { message, restriction: method },
            loc: {
              start: vitestFnCall.members[0].loc.start,
              end: vitestFnCall.members[vitestFnCall.members.length - 1].loc.end
            }
          });
        }
      }
    };
  }
});

const RULE_NAME$C = "consistent-test-filename";
const defaultPattern = /.*\.test\.[tj]sx?$/;
const defaultTestsPattern = /.*\.(test|spec)\.[tj]sx?$/;
const consistentTestFilename = createEslintRule({
  name: RULE_NAME$C,
  meta: {
    type: "problem",
    docs: {
      recommended: "error",
      requiresTypeChecking: false,
      description: "forbidden .spec test file pattern"
    },
    messages: {
      msg: "use test file name pattern {{pattern}}"
    },
    schema: [
      {
        type: "object",
        additionalProperties: false,
        properties: {
          pattern: {
            format: "regex",
            default: defaultPattern.source
          },
          allTestPattern: {
            format: "regex",
            default: defaultTestsPattern.source
          }
        }
      }
    ]
  },
  defaultOptions: [{ pattern: defaultTestsPattern.source, allTestPattern: defaultTestsPattern.source }],
  create: (context) => {
    const config = context.options[0] ?? {};
    const { pattern: patternRaw = defaultPattern, allTestPattern: allTestPatternRaw = defaultTestsPattern } = config;
    const pattern = typeof patternRaw === "string" ? new RegExp(patternRaw) : patternRaw;
    const testPattern = typeof allTestPatternRaw === "string" ? new RegExp(allTestPatternRaw) : allTestPatternRaw;
    const filename = path__namespace.basename(context.getFilename());
    if (!testPattern.test(filename))
      return {};
    return {
      Program: (p) => {
        if (!pattern.test(filename)) {
          context.report({
            node: p,
            messageId: "msg",
            data: {
              pattern: pattern.source
            }
          });
        }
      }
    };
  }
});

const RULE_NAME$B = "max-expects";
const maxExpect = createEslintRule({
  name: RULE_NAME$B,
  meta: {
    docs: {
      requiresTypeChecking: false,
      recommended: "error",
      description: "Enforce a maximum number of expect per test"
    },
    messages: {
      maxExpect: "Too many assertion calls ({{count}}). Maximum is {{max}}."
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          max: {
            type: "number"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{ max: 5 }],
  create(context, [{ max }]) {
    let assertsCount = 0;
    const resetAssertCount = (node) => {
      const isFunctionTest = node.parent?.type !== utils.AST_NODE_TYPES.CallExpression || isTypeOfVitestFnCall(node.parent, context, ["test"]);
      if (isFunctionTest)
        assertsCount = 0;
    };
    return {
      FunctionExpression: resetAssertCount,
      "FunctionExpression:exit": resetAssertCount,
      ArrowFunctionExpression: resetAssertCount,
      "ArrowFunctionExpression:exit": resetAssertCount,
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect" || vitestFnCall.head.node.parent?.type === utils.AST_NODE_TYPES.MemberExpression)
          return;
        assertsCount += 1;
        if (assertsCount > max) {
          context.report({
            node,
            messageId: "maxExpect",
            data: {
              count: assertsCount,
              max
            }
          });
        }
      }
    };
  }
});

const RULE_NAME$A = "no-alias-methods";
const noAliasMethod = createEslintRule({
  name: RULE_NAME$A,
  meta: {
    docs: {
      description: "Disallow alias methods",
      requiresTypeChecking: false,
      recommended: "error"
    },
    messages: {
      noAliasMethods: "Replace {{	alias }}() with its canonical name {{ canonical }}()"
    },
    type: "suggestion",
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const methodNames = {
      toBeCalled: "toHaveBeenCalled",
      toBeCalledTimes: "toHaveBeenCalledTimes",
      toBeCalledWith: "toHaveBeenCalledWith",
      lastCalledWith: "toHaveBeenLastCalledWith",
      nthCalledWith: "toHaveBeenNthCalledWith",
      toReturn: "toHaveReturned",
      toReturnTimes: "toHaveReturnedTimes",
      toReturnWith: "toHaveReturnedWith",
      lastReturnedWith: "toHaveLastReturnedWith",
      nthReturnedWith: "toHaveNthReturnedWith",
      toThrowError: "toThrow"
    };
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        const { matcher } = vitestFnCall;
        const alias = getAccessorValue(matcher);
        if (alias in methodNames) {
          const canonical = methodNames[alias];
          context.report({
            messageId: "noAliasMethods",
            data: { alias, canonical },
            node: matcher,
            fix: (fixer) => [replaceAccessorFixer(fixer, matcher, canonical)]
          });
        }
      }
    };
  }
});

const RULE_NAME$z = "no-commented-out-tests";
function hasTests(node) {
  return /^\s*[xf]?(test|it|describe)(\.\w+|\[['"]\w+['"]\])?\s*\(/mu.test(
    node.value
  );
}
const noCommentedOutTests = createEslintRule({
  name: RULE_NAME$z,
  meta: {
    docs: {
      description: "Disallow commented out tests",
      requiresTypeChecking: false,
      recommended: "warn"
    },
    messages: {
      noCommentedOutTests: "Remove commented out tests"
    },
    schema: [],
    type: "suggestion"
  },
  defaultOptions: [],
  create(context) {
    const sourceCode = context.getSourceCode();
    function checkNodeForCommentedOutTests(node) {
      if (!hasTests(node))
        return;
      context.report({ messageId: "noCommentedOutTests", node });
    }
    return {
      Program() {
        const comments = sourceCode.getAllComments();
        comments.forEach(checkNodeForCommentedOutTests);
      }
    };
  }
});

const RULE_NAME$y = "no-conditional-expect";
const isCatchCall = (node) => node.callee.type === utils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.callee.property, "catch");
const noConditonalExpect = createEslintRule({
  name: RULE_NAME$y,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow conditional expects",
      requiresTypeChecking: false,
      recommended: "error"
    },
    messages: {
      noConditionalExpect: "Avoid calling `expect` inside conditional statements"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    let conditionalDepth = 0;
    let inTestCase = false;
    let inPromiseCatch = false;
    const increaseConditionalDepth = () => inTestCase && conditionalDepth++;
    const decreaseConditionalDepth = () => inTestCase && conditionalDepth--;
    return {
      FunctionDeclaration(node) {
        const declaredVariables = context.getDeclaredVariables(node);
        const testCallExpressions = getTestCallExpressionsFromDeclaredVariables(declaredVariables, context);
        if (testCallExpressions.length > 0)
          inTestCase = true;
      },
      CallExpression(node) {
        const { type: vitestFnCallType } = parseVitestFnCall(node, context) ?? {};
        if (vitestFnCallType === "test")
          inTestCase = true;
        if (isCatchCall(node))
          inPromiseCatch = true;
        if (inTestCase && vitestFnCallType === "expect" && conditionalDepth > 0) {
          context.report({
            messageId: "noConditionalExpect",
            node
          });
        }
        if (inPromiseCatch && vitestFnCallType === "expect") {
          context.report({
            messageId: "noConditionalExpect",
            node
          });
        }
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["test"]))
          inTestCase = false;
        if (isCatchCall(node))
          inPromiseCatch = false;
      },
      CatchClause: increaseConditionalDepth,
      "CatchClause:exit": decreaseConditionalDepth,
      IfStatement: increaseConditionalDepth,
      "IfStatement:exit": decreaseConditionalDepth,
      SwitchStatement: increaseConditionalDepth,
      "SwitchStatement:exit": decreaseConditionalDepth,
      ConditionalExpression: increaseConditionalDepth,
      "ConditionalExpression:exit": decreaseConditionalDepth,
      LogicalExpression: increaseConditionalDepth,
      "LogicalExpression:exit": decreaseConditionalDepth
    };
  }
});

const RULE_NAME$x = "no-conditional-in-test";
const noConditionalInTest = createEslintRule({
  name: RULE_NAME$x,
  meta: {
    docs: {
      description: "Disallow conditional tests",
      requiresTypeChecking: false,
      recommended: "warn"
    },
    messages: {
      noConditionalInTest: "Remove conditional tests"
    },
    schema: [],
    type: "problem"
  },
  defaultOptions: [],
  create(context) {
    let inTestCase = false;
    const reportCondional = (node) => {
      if (inTestCase)
        context.report({ messageId: "noConditionalInTest", node });
    };
    return {
      CallExpression(node) {
        if (isTypeOfVitestFnCall(node, context, ["test"]))
          inTestCase = true;
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["test"]))
          inTestCase = false;
      },
      IfStatement: reportCondional,
      SwitchStatement: reportCondional,
      ConditionalExpression: reportCondional,
      LogicalExpression: reportCondional
    };
  }
});

const RULE_NAME$w = "no-disabled-tests";
const noDisabledTests = createEslintRule({
  name: RULE_NAME$w,
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow disabled tests",
      recommended: false
    },
    messages: {
      missingFunction: "Test is missing function argument",
      pending: "Call to pending()",
      pendingSuite: "Call to pending() within test suite",
      pendingTest: "Call to pending() within test",
      disabledSuite: "Disabled test suite",
      disabledTest: "Disabled test"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    let suiteDepth = 0;
    let testDepth = 0;
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!vitestFnCall)
          return;
        if (vitestFnCall.type === "describe")
          suiteDepth++;
        if (vitestFnCall.type === "test") {
          testDepth++;
          if (node.arguments.length < 2 && vitestFnCall.members.every((s) => getAccessorValue(s) === "skip")) {
            context.report({
              messageId: "missingFunction",
              node
            });
          }
        }
        if (vitestFnCall.name.startsWith("x") || vitestFnCall.members.some((s) => getAccessorValue(s) === "skip")) {
          context.report({
            messageId: vitestFnCall.type === "describe" ? "disabledSuite" : "disabledTest",
            node
          });
        }
      },
      "CallExpression:exit"(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!vitestFnCall)
          return;
        if (vitestFnCall.type === "describe")
          suiteDepth--;
        if (vitestFnCall.type === "test")
          testDepth--;
      },
      'CallExpression[callee.name="pending"]'(node) {
        if (resolveScope(context.getScope(), "pending"))
          return;
        if (testDepth > 0)
          context.report({ messageId: "pendingTest", node });
        else if (suiteDepth > 0)
          context.report({ messageId: "pendingSuite", node });
        else
          context.report({ messageId: "pending", node });
      }
    };
  }
});

const RULE_NAME$v = "no-done-callback";
const findCallbackArg = (node, isVitestEach, context) => {
  if (isVitestEach)
    return node.arguments[1];
  const vitestFnCall = parseVitestFnCall(node, context);
  if (vitestFnCall?.type === "hook" && node.arguments.length >= 1)
    return node.arguments[0];
  if (vitestFnCall?.type === "test" && node.arguments.length >= 2)
    return node.arguments[1];
  return null;
};
const noDoneCallback = createEslintRule({
  name: RULE_NAME$v,
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow using a callback in asynchrounous tests and hooks",
      recommended: "error"
    },
    schema: [],
    messages: {
      noDoneCallback: "Return a promise instead of relying on callback parameter",
      suggestWrappingInPromise: "Wrap in `new Promise({{ callback }} => ...`",
      useAwaitInsteadOfCallback: "Use `await` instead of callback in async function"
    },
    hasSuggestions: true
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const isVitestEach = getNodeName(node.callee)?.endsWith(".each") ?? false;
        if (isVitestEach && node.callee.type !== utils.AST_NODE_TYPES.TaggedTemplateExpression)
          return;
        const callback = findCallbackArg(node, isVitestEach, context);
        const callbackArgIndex = Number(isVitestEach);
        if (!callback || !isFunction(callback) || callback.params.length !== 1 + callbackArgIndex)
          return;
        const argument = callback.params[callbackArgIndex];
        if (argument.type !== utils.AST_NODE_TYPES.Identifier) {
          context.report({
            node: argument,
            messageId: "noDoneCallback"
          });
          return;
        }
        if (callback.async) {
          context.report({
            node: argument,
            messageId: "useAwaitInsteadOfCallback"
          });
          return;
        }
        context.report({
          node,
          messageId: "noDoneCallback",
          suggest: [
            {
              messageId: "suggestWrappingInPromise",
              data: { callback: argument.name },
              fix(fixer) {
                const { body, params } = callback;
                const sourceCode = context.getSourceCode();
                const firstBodyToken = sourceCode.getFirstToken(body);
                const lastBodyToken = sourceCode.getLastToken(body);
                const [firstParam] = params;
                const lastParam = params[params.length - 1];
                const tokenBeforeFirstParam = sourceCode.getTokenBefore(firstParam);
                let tokenAfterLastParam = sourceCode.getTokenAfter(lastParam);
                if (tokenAfterLastParam?.value === ",")
                  tokenAfterLastParam = sourceCode.getTokenAfter(tokenAfterLastParam);
                if (!firstBodyToken || !lastBodyToken || !tokenBeforeFirstParam || !tokenAfterLastParam)
                  throw new Error(`Unexpected null when attempting to fix ${context.getFilename()} - please file an issue at https://github/veritem/eslint-plugin-vitest`);
                let argumentFix = fixer.replaceText(firstParam, "()");
                if (tokenBeforeFirstParam.value === "(" && tokenAfterLastParam.value === ")")
                  argumentFix = fixer.removeRange([tokenBeforeFirstParam.range[1], tokenAfterLastParam.range[0]]);
                const newCallBack = argument.name;
                let beforeReplacement = `new Promise(${newCallBack} => `;
                let afterReplacement = ")";
                let replaceBefore = true;
                if (body.type === utils.AST_NODE_TYPES.BlockStatement) {
                  const keyword = "return";
                  beforeReplacement = `${keyword} ${beforeReplacement}{`;
                  afterReplacement += "}";
                  replaceBefore = false;
                }
                return [
                  argumentFix,
                  replaceBefore ? fixer.insertTextBefore(firstBodyToken, beforeReplacement) : fixer.insertTextAfter(firstBodyToken, beforeReplacement),
                  fixer.insertTextAfter(lastBodyToken, afterReplacement)
                ];
              }
            }
          ]
        });
      }
    };
  }
});

const RULE_NAME$u = "no-duplicate-hooks";
const noDuplicateHooks = createEslintRule({
  name: RULE_NAME$u,
  meta: {
    docs: {
      recommended: "error",
      description: "Disallow duplicate hooks and teardown hooks",
      requiresTypeChecking: false
    },
    messages: {
      noDuplicateHooks: "Duplicate {{hook}} in describe block."
    },
    schema: [],
    type: "suggestion"
  },
  defaultOptions: [],
  create(context) {
    const hooksContexts = [{}];
    return {
      CallExpression(node) {
        var _a;
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type === "describe")
          hooksContexts.push({});
        if (vitestFnCall?.type !== "hook")
          return;
        const currentLayer = hooksContexts[hooksContexts.length - 1];
        currentLayer[_a = vitestFnCall.name] || (currentLayer[_a] = 0);
        currentLayer[vitestFnCall.name] += 1;
        if (currentLayer[vitestFnCall.name] > 1) {
          context.report({
            messageId: "noDuplicateHooks",
            data: { hook: vitestFnCall.name },
            node
          });
        }
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["describe"]))
          hooksContexts.pop();
      }
    };
  }
});

const RULE_NAME$t = "no-large-snapshots";
const reportOnViolation = (context, node, { maxSize: lineLimit = 50, allowedSnapshots = {} }) => {
  const startLine = node.loc.start.line;
  const endLine = node.loc.end.line;
  const lineCount = endLine - startLine;
  const allPathsAreAbsolute = Object.keys(allowedSnapshots).every(path.isAbsolute);
  if (!allPathsAreAbsolute)
    throw new Error("All paths for allowedSnapshots must be absolute. You can use JS config and `path.resolve`");
  let isAllowed = false;
  if (node.type === utils.AST_NODE_TYPES.ExpressionStatement && "left" in node.expression && node.expression.left.type === utils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.expression.left.property)) {
    const fileName = context.getFilename();
    const allowedSnapshotsInFile = allowedSnapshots[fileName];
    if (allowedSnapshotsInFile) {
      const snapshotName = getAccessorValue(node.expression.left.property);
      isAllowed = allowedSnapshotsInFile.some((name) => {
        if (name instanceof RegExp)
          return name.test(snapshotName);
        return snapshotName === name;
      });
    }
  }
  if (!isAllowed && lineCount > lineLimit) {
    context.report({
      node,
      messageId: lineLimit === 0 ? "noSnapShot" : "tooLongSnapShot",
      data: {
        lineCount,
        lineLimit
      }
    });
  }
};
const noLargeSnapshots = createEslintRule({
  name: RULE_NAME$t,
  meta: {
    docs: {
      description: "Disallow large snapshots",
      recommended: "warn"
    },
    messages: {
      noSnapShot: "`{{ lineCount }}`s should begin with lowercase",
      tooLongSnapShot: "Expected vitest snapshot to be smaller than {{ lineLimit }} lines but was {{ lineCount }} lines long"
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          maxSize: {
            type: "number"
          },
          inlineMaxSize: {
            type: "number"
          },
          allowedSnapshots: {
            type: "object",
            additionalProperties: { type: "array" }
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{}],
  create(context, [options]) {
    if (context.getFilename().endsWith(".snap")) {
      return {
        ExpressionStatement(node) {
          reportOnViolation(context, node, options);
        }
      };
    }
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        if ([
          "toMatchInlineSnapshot",
          "toThrowErrorMatchingInlineSnapshot"
        ].includes(getAccessorValue(vitestFnCall.matcher)) && vitestFnCall.args.length) {
          reportOnViolation(context, vitestFnCall.args[0], {
            ...options,
            maxSize: options.inlineMaxSize ?? options.maxSize
          });
        }
      }
    };
  }
});

const RULE_NAME$s = "no-interpolation-in-snapshots";
const nonInterpolationInSnapShots = createEslintRule({
  name: RULE_NAME$s,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow string interpolation in snapshots",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      noInterpolationInSnapshots: "Do not use string interpolation in snapshots"
    }
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        if ([
          "toMatchInlineSnapshot",
          "toThrowErrorMatchingInlineSnapshot"
        ].includes(getAccessorValue(vitestFnCall.matcher))) {
          vitestFnCall.args.forEach((argument) => {
            if (argument.type === utils.AST_NODE_TYPES.TemplateLiteral && argument.expressions.length > 0) {
              context.report({
                messageId: "noInterpolationInSnapshots",
                node: argument
              });
            }
          });
        }
      }
    };
  }
});

const mocksDirName = "__mocks__";
const isMockPath = (path$1) => path$1.split(path.posix.sep).includes(mocksDirName);
const isMockImportLiteral = (expression) => isStringNode(expression) && isMockPath(getStringValue(expression));
const RULE_NAME$r = "no-mocks-import";
const noMocksImport = createEslintRule({
  name: RULE_NAME$r,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow importing from __mocks__ directory",
      recommended: "error"
    },
    messages: {
      noMocksImport: `Mocks should not be manually imported from a ${mocksDirName} directory. Instead use \`jest.mock\` and import from the original module path.`
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      ImportDeclaration(node) {
        if (isMockImportLiteral(node.source))
          context.report({ node, messageId: "noMocksImport" });
      },
      'CallExpression[callee.name="require"]'(node) {
        const [args] = node.arguments;
        if (args && isMockImportLiteral(args))
          context.report({ node: args, messageId: "noMocksImport" });
      }
    };
  }
});

const RULE_NAME$q = "no-restricted-matchers";
const isChainRestricted = (chain, restriction) => {
  if (ModifierName.hasOwnProperty(restriction) || restriction.endsWith(".not"))
    return chain.startsWith(restriction);
  return chain === restriction;
};
const noRestrictedMatchers = createEslintRule({
  name: RULE_NAME$q,
  meta: {
    docs: {
      description: "Disallow the use of certain matchers",
      recommended: "error"
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        additionalProperties: {
          type: ["string", "null"]
        }
      }
    ],
    messages: {
      restrictedChain: "use of `{{ matcher }}` is disallowed",
      restrictedChainWithMessage: "{{ message }}"
    }
  },
  defaultOptions: [{}],
  create(context, [restrictedChains]) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        const chain = vitestFnCall.members.map((node2) => getAccessorValue(node2)).join(".");
        for (const [restriction, message] of Object.entries(restrictedChains)) {
          if (isChainRestricted(chain, restriction)) {
            context.report({
              messageId: message ? "restrictedChainWithMessage" : "restrictedChain",
              data: { message, restriction },
              loc: {
                start: vitestFnCall.members[0].loc.start,
                end: vitestFnCall.members[vitestFnCall.members.length - 1].loc.end
              }
            });
            break;
          }
        }
      }
    };
  }
});

const RULE_NAME$p = "no-standalone-expect";
const getBlockType = (statement, context) => {
  const func = statement.parent;
  if (!func)
    throw new Error("Unexpected block statement. If you feel like this is a bug report https://github.com/veritem/eslint-plugin-vitest/issues/new");
  if (func.type === utils.AST_NODE_TYPES.FunctionDeclaration)
    return "function";
  if (isFunction(func) && func.parent) {
    const expr = func.parent;
    if (expr.type === utils.AST_NODE_TYPES.VariableDeclarator)
      return "function";
    if (expr.type === utils.AST_NODE_TYPES.CallExpression && isTypeOfVitestFnCall(expr, context, ["describe"]))
      return "describe";
  }
  return null;
};
const noStandaloneExpect = createEslintRule({
  name: RULE_NAME$p,
  meta: {
    docs: {
      description: "Disallow using `expect` outside of `it` or `test` blocks",
      recommended: "warn"
    },
    type: "suggestion",
    messages: {
      noStandaloneExpect: "Expect must be called inside a test block"
    },
    schema: [
      {
        properties: {
          additionalTestBlockFunctions: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{ additionalTestBlockFunctions: [] }],
  create(context, [{ additionalTestBlockFunctions = [] }]) {
    const callStack = [];
    const isCustomTestBlockFunction = (node) => additionalTestBlockFunctions.includes(getNodeName(node) || "");
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type === "expect") {
          if (vitestFnCall.head.node.parent?.type === utils.AST_NODE_TYPES.MemberExpression && vitestFnCall.members.length === 1 && !["assertions", "hasAssertions"].includes(
            getAccessorValue(vitestFnCall.members[0])
          ))
            return;
          const parent = callStack[callStack.length - 1];
          if (!parent || parent === DescribeAlias.describe)
            context.report({ node, messageId: "noStandaloneExpect" });
          return;
        }
        if (vitestFnCall?.type === "test" || isCustomTestBlockFunction(node))
          callStack.push("test");
        if (node.callee.type === utils.AST_NODE_TYPES.TaggedTemplateExpression)
          callStack.push("template");
      },
      "CallExpression:exit"(node) {
        const top = callStack[callStack.length - 1];
        if (top === "test" && (isTypeOfVitestFnCall(node, context, ["test"]) || isCustomTestBlockFunction(node)) && node.callee.type !== utils.AST_NODE_TYPES.MemberExpression || top === "template" && node.callee.type === utils.AST_NODE_TYPES.TaggedTemplateExpression)
          callStack.pop();
      },
      BlockStatement(statement) {
        const blockType = getBlockType(statement, context);
        if (blockType)
          callStack.push(blockType);
      },
      "BlockStatement:exit"(statement) {
        const blockType = getBlockType(statement, context);
        if (blockType)
          callStack.pop();
      },
      ArrowFunctionExpression(node) {
        if (node.parent?.type !== utils.AST_NODE_TYPES.CallExpression)
          callStack.push("arrow");
      },
      "ArrowFunctionExpression:exit"() {
        if (callStack[callStack.length - 1] === "arrow")
          callStack.pop();
      }
    };
  }
});

const RULE_NAME$o = "no-test-prefixes";
const noTestPrefixes = createEslintRule({
  name: RULE_NAME$o,
  meta: {
    docs: {
      description: "Disallow using `test` as a prefix",
      recommended: "warn"
    },
    type: "suggestion",
    messages: {
      usePreferredName: 'Use "{{preferredNodeName}}" instead'
    },
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "describe" && vitestFnCall?.type !== "test")
          return;
        if (vitestFnCall.name[0] !== "f" && vitestFnCall.name[0] !== "x")
          return;
        const preferredNodeName = [
          vitestFnCall.name.slice(1),
          vitestFnCall.name[0] === "f" ? "only" : "skip",
          ...vitestFnCall.members.map((m) => getAccessorValue(m))
        ].join(".");
        const funcNode = node.callee.type === utils.AST_NODE_TYPES.TaggedTemplateExpression ? node.callee.tag : node.callee.type === utils.AST_NODE_TYPES.CallExpression ? node.callee.callee : node.callee;
        context.report({
          messageId: "usePreferredName",
          node: node.callee,
          data: { preferredNodeName },
          fix: (fixer) => [fixer.replaceText(funcNode, preferredNodeName)]
        });
      }
    };
  }
});

const RULE_NAME$n = "no-test-return-statement";
const getBody = (args) => {
  const [, secondArg] = args;
  if (secondArg && isFunction(secondArg) && secondArg.body.type === utils.AST_NODE_TYPES.BlockStatement)
    return secondArg.body.body;
  return [];
};
const noTestReturnStatement = createEslintRule({
  name: RULE_NAME$n,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow return statements in tests",
      recommended: "error"
    },
    schema: [],
    messages: {
      noTestReturnStatement: "Return statements are not allowed in tests"
    }
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        if (!isTypeOfVitestFnCall(node, context, ["test"]))
          return;
        const body = getBody(node.arguments);
        const returnStmt = body.find((stmt) => stmt.type === utils.AST_NODE_TYPES.ReturnStatement);
        if (!returnStmt)
          return;
        context.report({ messageId: "noTestReturnStatement", node: returnStmt });
      },
      FunctionDeclaration(node) {
        const declaredVariables = context.getDeclaredVariables(node);
        const testCallExpressions = getTestCallExpressionsFromDeclaredVariables(declaredVariables, context);
        if (testCallExpressions.length === 0)
          return;
        const returnStmt = node.body.body.find((stmt) => stmt.type === utils.AST_NODE_TYPES.ReturnStatement);
        if (!returnStmt)
          return;
        context.report({ messageId: "noTestReturnStatement", node: returnStmt });
      }
    };
  }
});

const RULE_NAME$m = "prefer-called-with";
const preferCalledWith = createEslintRule({
  name: RULE_NAME$m,
  meta: {
    docs: {
      description: "Suggest using `toBeCalledWith()` or `toHaveBeenCalledWith()`",
      recommended: "warn"
    },
    messages: {
      preferCalledWith: "Prefer {{ matcherName }}With(/* expected args */)"
    },
    type: "suggestion",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        if (vitestFnCall.modifiers.some((node2) => getAccessorValue(node2) === "not"))
          return;
        const { matcher } = vitestFnCall;
        const matcherName = getAccessorValue(matcher);
        if (["toBeCalled", "toHaveBeenCalled"].includes(matcherName)) {
          context.report({
            data: { matcherName },
            messageId: "preferCalledWith",
            node: matcher
          });
        }
      }
    };
  }
});

const RULE_NAME$l = "valid-title";
const trimFXprefix = (word) => ["f", "x"].includes(word.charAt(0)) ? word.substring(1) : word;
const quoteStringValue = (node) => node.type === utils.AST_NODE_TYPES.TemplateLiteral ? `\`${node.quasis[0].value.raw}\`` : node.raw;
const MatcherAndMessageSchema = {
  type: "array",
  items: { type: "string" },
  minItems: 1,
  maxItems: 2,
  additionalItems: false
};
const compileMatcherPattern = (matcherMaybeWithMessage) => {
  const [matcher, message] = Array.isArray(matcherMaybeWithMessage) ? matcherMaybeWithMessage : [matcherMaybeWithMessage];
  return [new RegExp(matcher, "u"), message];
};
const compileMatcherPatterns = (matchers) => {
  if (typeof matchers === "string" || Array.isArray(matchers)) {
    const compiledMatcher = compileMatcherPattern(matchers);
    return {
      describe: compiledMatcher,
      test: compiledMatcher,
      it: compiledMatcher
    };
  }
  return {
    describe: matchers.describe ? compileMatcherPattern(matchers.describe) : null,
    test: matchers.test ? compileMatcherPattern(matchers.test) : null,
    it: matchers.it ? compileMatcherPattern(matchers.it) : null
  };
};
const doesBinaryExpressionContainStringNode = (binaryExp) => {
  if (isStringNode(binaryExp.right))
    return true;
  if (binaryExp.left.type === utils.AST_NODE_TYPES.BinaryExpression)
    return doesBinaryExpressionContainStringNode(binaryExp.left);
  return isStringNode(binaryExp.left);
};
const validTitle = createEslintRule({
  name: RULE_NAME$l,
  meta: {
    docs: {
      description: "Enforce valid titles",
      recommended: "error"
    },
    messages: {
      titleMustBeString: "Test title must be a string",
      emptyTitle: "{{functionName}} should not have an empty title",
      duplicatePrefix: "should not have duplicate prefix",
      accidentalSpace: "should not have leading or trailing spaces",
      disallowedWord: '"{{word}}" is not allowed in test title',
      mustNotMatch: "{{functionName}} should not match {{pattern}}",
      mustMatch: "{{functionName}} should match {{pattern}}",
      mustNotMatchCustom: "{{message}}",
      mustMatchCustom: "{{message}}"
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          ignoreTypeOfDescribeName: {
            type: "boolean",
            default: false
          },
          disallowedWords: {
            type: "array",
            items: { type: "string" }
          }
        },
        patternProperties: {
          [/^must(?:Not)?Match$/u.source]: {
            oneOf: [
              { type: "string" },
              MatcherAndMessageSchema,
              {
                type: "object",
                propertyNames: { enum: ["describe", "test", "it"] },
                additionalProperties: {
                  oneOf: [{ type: "string" }, MatcherAndMessageSchema]
                }
              }
            ]
          }
        },
        additionalProperties: false
      }
    ],
    fixable: "code"
  },
  defaultOptions: [{ ignoreTypeOfDescribeName: false, disallowedWords: [] }],
  create(context, [
    {
      ignoreTypeOfDescribeName,
      disallowedWords = [],
      mustNotMatch,
      mustMatch
    }
  ]) {
    const disallowedWordsRegexp = new RegExp(`\\b(${disallowedWords.join("|")})\\b`, "iu");
    const mustNotMatchPatterns = compileMatcherPatterns(mustNotMatch ?? {});
    const mustMatchPatterns = compileMatcherPatterns(mustMatch ?? {});
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "describe" && vitestFnCall?.type !== "test")
          return;
        const [argument] = node.arguments;
        if (!argument)
          return;
        if (!isStringNode(argument)) {
          if (argument.type === utils.AST_NODE_TYPES.BinaryExpression && doesBinaryExpressionContainStringNode(argument))
            return;
          if (argument.type !== utils.AST_NODE_TYPES.TemplateLiteral && !(ignoreTypeOfDescribeName && vitestFnCall.type === "describe")) {
            context.report({
              messageId: "titleMustBeString",
              loc: argument.loc
            });
          }
          return;
        }
        const title = getStringValue(argument);
        if (!title) {
          context.report({
            messageId: "emptyTitle",
            data: {
              functionName: vitestFnCall.type === "describe" ? DescribeAlias.describe : TestCaseName.test
            },
            node
          });
          return;
        }
        if (disallowedWords.length > 0) {
          const disallowedMatch = disallowedWordsRegexp.exec(title);
          if (disallowedMatch) {
            context.report({
              messageId: "disallowedWord",
              data: {
                word: disallowedMatch[1]
              },
              node: argument
            });
            return;
          }
        }
        if (title.trim().length !== title.length) {
          context.report({
            messageId: "accidentalSpace",
            node: argument,
            fix: (fixer) => [
              fixer.replaceTextRange(
                argument.range,
                quoteStringValue(argument).replace(/^([`'"]) +?/u, "$1").replace(/ +?([`'"])$/u, "$1")
              )
            ]
          });
        }
        const unprefixedName = trimFXprefix(vitestFnCall.name);
        const [firstword] = title.split(" ");
        if (firstword.toLowerCase() === unprefixedName) {
          context.report({
            messageId: "duplicatePrefix",
            node: argument,
            fix: (fixer) => [
              fixer.replaceTextRange(
                argument.range,
                quoteStringValue(argument).replace(/^([`'"]).+? /u, "$1")
              )
            ]
          });
        }
        const vitestFnName = unprefixedName;
        const [mustNotMatchPattern, mustNotMatchMessage] = mustNotMatchPatterns[vitestFnName] ?? [];
        if (mustNotMatchPattern) {
          if (mustNotMatchPattern.test(title)) {
            context.report({
              messageId: mustNotMatchMessage ? "mustNotMatchCustom" : "mustNotMatch",
              node: argument,
              data: {
                functionName: vitestFnName,
                pattern: mustNotMatchPattern,
                message: mustNotMatchMessage
              }
            });
            return;
          }
        }
        const [mustMatchPattern, mustMatchMessage] = mustMatchPatterns[vitestFnName] ?? [];
        if (mustMatchPattern) {
          if (!mustMatchPattern.test(title)) {
            context.report({
              messageId: mustMatchMessage ? "mustMatchCustom" : "mustMatch",
              node: argument,
              data: {
                functionName: vitestFnName,
                pattern: mustMatchPattern,
                message: mustMatchMessage
              }
            });
          }
        }
      }
    };
  }
});

const RULE_NAME$k = "valid-expect";
const defaultAsyncMatchers = ["toReject", "toResolve"];
const getPromiseCallExpressionNode = (node) => {
  if (node.type === utils.AST_NODE_TYPES.ArrayExpression && node.parent && node.parent.type === utils.AST_NODE_TYPES.CallExpression)
    node = node.parent;
  if (node.type === utils.AST_NODE_TYPES.CallExpression && node.callee.type === utils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.callee.object, "Promise") && node.parent)
    return node;
  return null;
};
const promiseArrayExceptionKey = ({ start, end }) => `${start.line}:${start.column}-${end.line}:${end.column}`;
function getParentIfThenified(node) {
  const grandParentNode = node.parent?.parent;
  if (grandParentNode && grandParentNode.type === utils.AST_NODE_TYPES.CallExpression && grandParentNode.callee.type === utils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(grandParentNode.callee.property) && ["then", "catch"].includes(getAccessorValue(grandParentNode.callee.property)) && grandParentNode.parent)
    return getParentIfThenified(grandParentNode);
  return node;
}
const findPromiseCallExpressionNode = (node) => node.parent?.parent && [utils.AST_NODE_TYPES.CallExpression, utils.AST_NODE_TYPES.ArrayExpression].includes(
  node.parent.type
) ? getPromiseCallExpressionNode(node.parent) : null;
const isAcceptableReturnNode = (node, allowReturn) => {
  if (allowReturn && node.type === utils.AST_NODE_TYPES.ReturnStatement)
    return true;
  if (node.type === utils.AST_NODE_TYPES.ConditionalExpression && node.parent)
    return isAcceptableReturnNode(node.parent, allowReturn);
  return [
    utils.AST_NODE_TYPES.ArrowFunctionExpression,
    utils.AST_NODE_TYPES.AwaitExpression
  ].includes(node.type);
};
const validExpect = createEslintRule({
  name: RULE_NAME$k,
  meta: {
    docs: {
      description: "Enforce valid `expect()` usage",
      recommended: "error"
    },
    messages: {
      tooManyArgs: "Expect takes most {{ amount}} argument{{s}}",
      notEnoughArgs: "Expect requires atleast {{ amount }} argument{{s}}",
      modifierUnknown: "Expect has unknown modifier",
      matcherNotFound: "Expect must have a corresponding matcher call.",
      matcherNotCalled: "Matchers must be called to assert.",
      asyncMustBeAwaited: "Async assertions must be awaited{{orReturned}}",
      promisesWithAsyncAssertionsMustBeAwaited: "Promises which return async assertions must be awaited{{orReturned}}"
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          alwaysAwait: {
            type: "boolean",
            default: false
          },
          asyncMatchers: {
            type: "array",
            items: { type: "string" }
          },
          minArgs: {
            type: "number",
            minimum: 1
          },
          maxArgs: {
            type: "number",
            minimum: 1
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{
    alwaysAwait: false,
    asyncMatchers: defaultAsyncMatchers,
    minArgs: 1,
    maxArgs: 1
  }],
  create: (context, [{ alwaysAwait, asyncMatchers = defaultAsyncMatchers, minArgs = 1, maxArgs = 1 }]) => {
    const arrayExceptions = /* @__PURE__ */ new Set();
    const pushPromiseArrayException = (loc) => arrayExceptions.add(promiseArrayExceptionKey(loc));
    const promiseArrayExceptionExists = (loc) => arrayExceptions.has(promiseArrayExceptionKey(loc));
    const findTopMostMemberExpression = (node) => {
      let topMostMemberExpression = node;
      let { parent } = node;
      while (parent) {
        if (parent.type !== utils.AST_NODE_TYPES.MemberExpression)
          break;
        topMostMemberExpression = parent;
        parent = parent.parent;
      }
      return topMostMemberExpression;
    };
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCallWithReason(node, context);
        if (typeof vitestFnCall === "string") {
          const reportingNode = node.parent?.type === utils.AST_NODE_TYPES.MemberExpression ? findTopMostMemberExpression(node.parent).property : node;
          if (vitestFnCall === "matcher-not-found") {
            context.report({
              messageId: "matcherNotFound",
              node: reportingNode
            });
            return;
          }
          if (vitestFnCall === "matcher-not-called") {
            context.report({
              messageId: isSupportedAccessor(reportingNode) && // eslint-disable-next-line no-prototype-builtins
              ModifierName.hasOwnProperty(getAccessorValue(reportingNode)) ? "matcherNotFound" : "matcherNotCalled",
              node: reportingNode
            });
          }
          if (vitestFnCall === "modifier-unknown") {
            context.report({
              messageId: "modifierUnknown",
              node: reportingNode
            });
            return;
          }
          return;
        } else if (vitestFnCall?.type !== "expect") {
          return;
        }
        const { parent: expect } = vitestFnCall.head.node;
        if (expect?.type !== utils.AST_NODE_TYPES.CallExpression)
          return;
        if (expect.arguments.length < minArgs) {
          const expectLength = getAccessorValue(vitestFnCall.head.node).length;
          const loc = {
            start: {
              column: expect.loc.start.column + expectLength,
              line: expect.loc.start.line
            },
            end: {
              column: expect.loc.start.column + expectLength + 1,
              line: expect.loc.start.line
            }
          };
          context.report({
            messageId: "notEnoughArgs",
            data: { amount: minArgs, s: minArgs === 1 ? "" : "s" },
            node: expect,
            loc
          });
        }
        if (expect.arguments.length > maxArgs) {
          const { start } = expect.arguments[maxArgs].loc;
          const { end } = expect.arguments[expect.arguments.length - 1].loc;
          const loc = {
            start,
            end: {
              column: end.column + 1,
              line: end.line
            }
          };
          context.report({
            messageId: "tooManyArgs",
            data: { amount: maxArgs, s: maxArgs === 1 ? "" : "s" },
            node: expect,
            loc
          });
        }
        const { matcher } = vitestFnCall;
        const parentNode = matcher.parent.parent;
        const shouldBeAwaited = vitestFnCall.modifiers.some((nod) => getAccessorValue(nod) !== "not") || asyncMatchers.includes(getAccessorValue(matcher));
        if (!parentNode?.parent || !shouldBeAwaited)
          return;
        const isParentArrayExpression = parentNode.parent.type === utils.AST_NODE_TYPES.ArrayExpression;
        const orReturned = alwaysAwait ? "" : " or returned";
        const targetNode = getParentIfThenified(parentNode);
        const finalNode = findPromiseCallExpressionNode(targetNode) || targetNode;
        if (finalNode.parent && !isAcceptableReturnNode(finalNode.parent, !alwaysAwait) && !promiseArrayExceptionExists(finalNode.loc)) {
          context.report({
            loc: finalNode.loc,
            data: { orReturned },
            messageId: finalNode === targetNode ? "asyncMustBeAwaited" : "promisesWithAsyncAssertionsMustBeAwaited",
            node
          });
          if (isParentArrayExpression)
            pushPromiseArrayException(finalNode.loc);
        }
      }
    };
  }
});

const isBooleanLiteral = (node) => node.type === utils.AST_NODE_TYPES.Literal && typeof node.value === "boolean";
const isBooleanEqualityMatcher = (expectFnCall) => {
  const matcherName = getAccessorValue(expectFnCall.matcher);
  if (["toBeTruthy", "toBeFalsy"].includes(matcherName))
    return true;
  if (expectFnCall.args.length !== 1)
    return false;
  const arg = getFirstMatcherArg(expectFnCall);
  return EqualityMatcher.hasOwnProperty(matcherName) && isBooleanLiteral(arg);
};
const isInstanceOfBinaryExpression = (node, className) => node.type === utils.AST_NODE_TYPES.BinaryExpression && node.operator === "instanceof" && isSupportedAccessor(node.right, className);
const hasOnlyOneArgument = (call) => call.arguments.length === 1;

const RULE_NAME$j = "prefer-to-be-object";
const preferToBeObject = createEslintRule({
  name: RULE_NAME$j,
  meta: {
    type: "suggestion",
    docs: {
      description: "Prefer toBeObject()",
      recommended: "error"
    },
    fixable: "code",
    messages: {
      preferToBeObject: "Prefer toBeObject() to test if a value is an object."
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expectTypeOf")
          return;
        if (isParsedInstanceOfMatcherCall(vitestFnCall, "Object")) {
          context.report({
            node: vitestFnCall.matcher,
            messageId: "preferToBeObject",
            fix: (fixer) => [
              fixer.replaceTextRange(
                [
                  vitestFnCall.matcher.range[0],
                  vitestFnCall.matcher.range[1] + "(Object)".length
                ],
                "toBeObject()"
              )
            ]
          });
          return;
        }
        const { parent: expectTypeOf } = vitestFnCall.head.node;
        if (expectTypeOf?.type !== utils.AST_NODE_TYPES.CallExpression)
          return;
        const [expectTypeOfArgs] = expectTypeOf.arguments;
        if (!expectTypeOfArgs || !isBooleanEqualityMatcher(vitestFnCall) || !isInstanceOfBinaryExpression(expectTypeOfArgs, "Object"))
          return;
        context.report({
          node: vitestFnCall.matcher,
          messageId: "preferToBeObject",
          fix(fixer) {
            const fixes = [
              fixer.replaceText(vitestFnCall.matcher, "toBeObject"),
              fixer.removeRange([expectTypeOfArgs.left.range[1], expectTypeOfArgs.range[1]])
            ];
            let invertCondition = getAccessorValue(vitestFnCall.matcher) === "toBeFalsy";
            if (vitestFnCall.args.length) {
              const [matcherArg] = vitestFnCall.args;
              fixes.push(fixer.remove(matcherArg));
              invertCondition = matcherArg.type === utils.AST_NODE_TYPES.Literal && followTypeAssertionChain(matcherArg).value === false;
            }
            if (invertCondition) {
              const notModifier = vitestFnCall.modifiers.find((node2) => getAccessorValue(node2) === "not");
              fixes.push(
                notModifier ? fixer.removeRange([
                  notModifier.range[0] - 1,
                  notModifier.range[1]
                ]) : fixer.insertTextBefore(vitestFnCall.matcher, "not.")
              );
            }
            return fixes;
          }
        });
      }
    };
  }
});

const RULE_NAME$i = "prefer-to-be-truthy";
const isTrueLiteral = (node) => node.type === utils.AST_NODE_TYPES.Literal && node.value === true;
const preferToBeTruthy = createEslintRule({
  name: RULE_NAME$i,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using `toBeTruthy`",
      recommended: "warn"
    },
    messages: {
      preferToBeTruthy: "Prefer using `toBeTruthy` to test value is `true`"
    },
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!(vitestFnCall?.type === "expect" || vitestFnCall?.type === "expectTypeOf"))
          return;
        if (vitestFnCall.args.length === 1 && isTrueLiteral(getFirstMatcherArg(vitestFnCall)) && // eslint-disable-next-line no-prototype-builtins
        EqualityMatcher.hasOwnProperty(getAccessorValue(vitestFnCall.matcher))) {
          context.report({
            node: vitestFnCall.matcher,
            messageId: "preferToBeTruthy",
            fix: (fixer) => [
              fixer.replaceText(vitestFnCall.matcher, "toBeTruthy"),
              fixer.remove(vitestFnCall.args[0])
            ]
          });
        }
      }
    };
  }
});

const RULE_NAME$h = "prefer-to-be-falsy";
const isFalseLiteral = (node) => node.type === utils.AST_NODE_TYPES.Literal && node.value === false;
const preferToBeFalsy = createEslintRule({
  name: RULE_NAME$h,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using toBeFalsy()",
      recommended: "warn"
    },
    fixable: "code",
    schema: [],
    messages: {
      preferToBeFalsy: "Prefer using toBeFalsy()"
    }
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!(vitestFnCall?.type === "expect" || vitestFnCall?.type === "expectTypeOf"))
          return;
        if (vitestFnCall.args.length === 1 && isFalseLiteral(getFirstMatcherArg(vitestFnCall)) && // eslint-disable-next-line no-prototype-builtins
        EqualityMatcher.hasOwnProperty(getAccessorValue(vitestFnCall.matcher))) {
          context.report({
            node: vitestFnCall.matcher,
            messageId: "preferToBeFalsy",
            fix: (fixer) => [
              fixer.replaceText(vitestFnCall.matcher, "toBeFalsy"),
              fixer.remove(vitestFnCall.args[0])
            ]
          });
        }
      }
    };
  }
});

const RULE_NAME$g = "prefer-to-have-length";
const preferToHaveLength = createEslintRule({
  name: RULE_NAME$g,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using toHaveLength()",
      recommended: false
    },
    fixable: "code",
    messages: {
      preferToHaveLength: "Prefer toHaveLength()"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        const { parent: expect } = vitestFnCall.head.node;
        if (expect?.type !== utils.AST_NODE_TYPES.CallExpression)
          return;
        const [argument] = expect.arguments;
        const { matcher } = vitestFnCall;
        if (!EqualityMatcher.hasOwnProperty(getAccessorValue(matcher)) || argument?.type !== utils.AST_NODE_TYPES.MemberExpression || !isSupportedAccessor(argument.property, "length"))
          return;
        context.report({
          node: matcher,
          messageId: "preferToHaveLength",
          fix(fixer) {
            return [
              fixer.removeRange([
                argument.property.range[0] - 1,
                argument.range[1]
              ]),
              fixer.replaceTextRange(
                [matcher.parent.object.range[1], matcher.parent.range[1]],
                ".toHaveLength"
              )
            ];
          }
        });
      }
    };
  }
});

const RULE_NAME$f = "prefer-equality-matcher";
const preferEqualityMatcher = createEslintRule({
  name: RULE_NAME$f,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using the built-in quality matchers",
      recommended: "warn"
    },
    messages: {
      useEqualityMatcher: "Prefer using one of the equality matchers instead",
      suggestEqualityMatcher: "Use `{{ equalityMatcher }}`"
    },
    hasSuggestions: true,
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect" || vitestFnCall.args.length === 0)
          return;
        const { parent: expect } = vitestFnCall.head.node;
        if (expect?.type !== utils.AST_NODE_TYPES.CallExpression)
          return;
        const {
          arguments: [comparison],
          range: [, expectCallEnd]
        } = expect;
        const { matcher } = vitestFnCall;
        const matcherArg = getFirstMatcherArg(vitestFnCall);
        if (comparison?.type !== utils.AST_NODE_TYPES.BinaryExpression || comparison.operator !== "===" && comparison.operator !== "!==" || // eslint-disable-next-line no-prototype-builtins
        !EqualityMatcher.hasOwnProperty(getAccessorValue(matcher)) || !isBooleanLiteral(matcherArg))
          return;
        const matcherValue = matcherArg.value;
        const [modifier] = vitestFnCall.modifiers;
        const hasNot = vitestFnCall.modifiers.some(
          (nod) => getAccessorValue(nod) === "not"
        );
        const addNotModifier = (comparison.operator === "!==" ? !matcherValue : matcherValue) === hasNot;
        const buildFixer = (equalityMatcher) => (fixer) => {
          const sourceCode = context.getSourceCode();
          let modifierText = modifier && getAccessorValue(modifier) !== "not" ? `.${getAccessorValue(modifier)}` : "";
          if (addNotModifier)
            modifierText += `.${ModifierName.not}`;
          return [
            fixer.replaceText(
              comparison,
              sourceCode.getText(comparison.left)
            ),
            fixer.replaceTextRange(
              [expectCallEnd, matcher.parent.range[1]],
              `${modifierText}.${equalityMatcher}`
            ),
            fixer.replaceText(
              matcherArg,
              sourceCode.getText(comparison.right)
            )
          ];
        };
        context.report({
          messageId: "useEqualityMatcher",
          suggest: ["toBe", "toEqual", "toStrictEqual"].map((equalityMatcher) => ({
            messageId: "suggestEqualityMatcher",
            data: { equalityMatcher },
            fix: buildFixer(equalityMatcher)
          })),
          node: matcher
        });
      }
    };
  }
});

const RULE_NAME$e = "prefer-strict-equal";
const preferStrictEqual = createEslintRule({
  name: RULE_NAME$e,
  meta: {
    type: "suggestion",
    docs: {
      description: "Prefer strict equal over equal",
      recommended: "warn"
    },
    messages: {
      useToStrictEqual: "Use `toStrictEqual()` instead",
      suggestReplaceWithStrictEqual: "Replace with `toStrictEqual()`"
    },
    schema: [],
    hasSuggestions: true
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        const { matcher } = vitestFnCall;
        if (isSupportedAccessor(matcher, "toEqual")) {
          context.report({
            messageId: "useToStrictEqual",
            node: matcher,
            suggest: [
              {
                messageId: "suggestReplaceWithStrictEqual",
                fix: (fixer) => [
                  replaceAccessorFixer(fixer, matcher, EqualityMatcher.toStrictEqual)
                ]
              }
            ]
          });
        }
      }
    };
  }
});

const RULE_NAME$d = "prefer-expect-resolves";
const preferExpectResolves = createEslintRule({
  name: RULE_NAME$d,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using `expect().resolves` over `expect(await ...)` syntax",
      recommended: "warn"
    },
    fixable: "code",
    messages: {
      expectResolves: "Use `expect().resolves` instead"
    },
    schema: []
  },
  defaultOptions: [],
  create: (context) => ({
    CallExpression(node) {
      const vitestFnCall = parseVitestFnCall(node, context);
      if (vitestFnCall?.type !== "expect")
        return;
      const { parent } = vitestFnCall.head.node;
      if (parent?.type !== utils.AST_NODE_TYPES.CallExpression)
        return;
      const [awaitNode] = parent.arguments;
      if (awaitNode?.type === utils.AST_NODE_TYPES.AwaitExpression) {
        context.report({
          node: awaitNode,
          messageId: "expectResolves",
          fix(fixer) {
            return [
              fixer.insertTextBefore(parent, "await "),
              fixer.removeRange([
                awaitNode.range[0],
                awaitNode.argument.range[0]
              ]),
              fixer.insertTextAfter(parent, ".resolves")
            ];
          }
        });
      }
    }
  })
});

const RULE_NAME$c = "prefer-each";
const preferEach = createEslintRule({
  name: RULE_NAME$c,
  meta: {
    type: "suggestion",
    docs: {
      description: "Prefer `each` rather than manual loops",
      recommended: "error"
    },
    schema: [],
    messages: {
      preferEach: "Prefer using `{{ fn }}.each` rather than a manual loop"
    }
  },
  defaultOptions: [],
  create(context) {
    const vitestFnCalls = [];
    let inTestCaseCall = false;
    const recommendFn = () => {
      if (vitestFnCalls.length === 1 && vitestFnCalls[0] === "test")
        return "it";
      return "describe";
    };
    const enterForLoop = () => {
      if (vitestFnCalls.length === 0 || inTestCaseCall)
        return;
      vitestFnCalls.length = 0;
    };
    const exitForLoop = (node) => {
      if (vitestFnCalls.length === 0 || inTestCaseCall)
        return;
      context.report({
        node,
        messageId: "preferEach",
        data: { fn: recommendFn() }
      });
      vitestFnCalls.length = 0;
    };
    return {
      ForStatement: enterForLoop,
      "ForStatement:exit": exitForLoop,
      ForInStatement: enterForLoop,
      "ForInStatement:exit": exitForLoop,
      ForOfStatement: enterForLoop,
      "ForOfStatement:exit": exitForLoop,
      CallExpression(node) {
        const { type: vitestFnCallType } = parseVitestFnCall(node, context) ?? {};
        if (vitestFnCallType === "hook" || vitestFnCallType === "describe" || vitestFnCallType === "test")
          vitestFnCalls.push(vitestFnCallType);
        if (vitestFnCallType === "test")
          inTestCaseCall = true;
      },
      "CallExpression:exit"(node) {
        const { type: vitestFnCallType } = parseVitestFnCall(node, context) ?? {};
        if (vitestFnCallType === "test")
          inTestCaseCall = false;
      }
    };
  }
});

const RULE_NAME$b = "prefer-hooks-on-top";
const preferHooksOnTop = createEslintRule({
  name: RULE_NAME$b,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest having hooks before any test cases",
      recommended: "error"
    },
    messages: {
      noHookOnTop: "Hooks should come before test cases"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const hooksContext = [false];
    return {
      CallExpression(node) {
        if (isTypeOfVitestFnCall(node, context, ["test"]))
          hooksContext[hooksContext.length - 1] = true;
        if (hooksContext[hooksContext.length - 1] && isTypeOfVitestFnCall(node, context, ["hook"])) {
          context.report({
            messageId: "noHookOnTop",
            node
          });
        }
        hooksContext.push(false);
      },
      "CallExpression:exit"() {
        hooksContext.pop();
      }
    };
  }
});

const RULE_NAME$a = "prefer-hooks-in-order";
const HooksOrder = ["beforeAll", "beforeEach", "afterEach", "afterAll"];
const preferHooksInOrder = createEslintRule({
  name: RULE_NAME$a,
  meta: {
    type: "suggestion",
    docs: {
      description: "Prefer having hooks in consistent order",
      recommended: "warn"
    },
    messages: {
      reorderHooks: "`{{ currentHook }}` hooks should be before any `{{ previousHook }}` hooks"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    let previousHookIndex = -1;
    let inHook = false;
    return {
      CallExpression(node) {
        if (inHook)
          return;
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "hook") {
          previousHookIndex = -1;
          return;
        }
        inHook = true;
        const currentHook = vitestFnCall.name;
        const currentHookIndex = HooksOrder.indexOf(currentHook);
        if (currentHookIndex < previousHookIndex) {
          context.report({
            messageId: "reorderHooks",
            data: {
              previousHook: HooksOrder[previousHookIndex],
              currentHook
            },
            node
          });
          inHook = false;
          return;
        }
        previousHookIndex = currentHookIndex;
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["hook"])) {
          inHook = false;
          return;
        }
        if (inHook)
          return;
        previousHookIndex = -1;
      }
    };
  }
});

const RULE_NAME$9 = "preferMockPromiseShorthand";
const withOnce = (name, addOnce) => {
  return `${name}${addOnce ? "Once" : ""}`;
};
const findSingleReturnArgumentNode = (fnNode) => {
  if (fnNode.body.type !== utils.AST_NODE_TYPES.BlockStatement)
    return fnNode.body;
  if (fnNode.body.body[0]?.type === utils.AST_NODE_TYPES.ReturnStatement)
    return fnNode.body.body[0].argument;
  return null;
};
const preferMockPromiseShorthand = createEslintRule({
  name: RULE_NAME$9,
  meta: {
    type: "suggestion",
    docs: {
      description: "Prefer mock resolved/rejected shorthands for promises",
      recommended: "warn"
    },
    messages: {
      useMockShorthand: "Prefer {{ replacement }}"
    },
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    const report = (property, isOnce, outerArgNode, innerArgNode = outerArgNode) => {
      if (innerArgNode?.type !== utils.AST_NODE_TYPES.CallExpression)
        return;
      const argName = getNodeName(innerArgNode);
      if (argName !== "Promise.resolve" && argName !== "Promise.reject")
        return;
      const replacement = withOnce(argName.endsWith("reject") ? "mockRejectedValue" : "mockResolvedValue", isOnce);
      context.report({
        node: property,
        messageId: "useMockShorthand",
        data: { replacement },
        fix(fixer) {
          const sourceCode = context.getSourceCode();
          if (innerArgNode.arguments.length > 1)
            return null;
          return [
            fixer.replaceText(property, replacement),
            fixer.replaceText(outerArgNode, innerArgNode.arguments.length === 1 ? sourceCode.getText(innerArgNode.arguments[0]) : "undefined")
          ];
        }
      });
    };
    return {
      CallExpression(node) {
        if (node.callee.type !== utils.AST_NODE_TYPES.MemberExpression || !isSupportedAccessor(node.callee.property) || node.arguments.length === 0)
          return;
        const mockFnName = getAccessorValue(node.callee.property);
        const isOnce = mockFnName.endsWith("Once");
        if (mockFnName === withOnce("mockReturnValue", isOnce)) {
          report(node.callee.property, isOnce, node.arguments[0]);
        } else if (mockFnName === withOnce("mockImplementation", isOnce)) {
          const [arg] = node.arguments;
          if (!isFunction(arg) || arg.params.length !== 0)
            return;
          report(
            node.callee.property,
            isOnce,
            arg,
            findSingleReturnArgumentNode(arg)
          );
        }
      }
    };
  }
});

const RULE_NAME$8 = "prefer-snapshot-hint";
const snapshotMatchers = ["toMatchSnapshot", "toThrowErrorMatchingSnapshot"];
const snapshotMatcherNames = snapshotMatchers;
const isSnapshotMatcherWithoutHint = (expectFnCall) => {
  if (expectFnCall.args.length === 0)
    return true;
  if (!isSupportedAccessor(expectFnCall.matcher, "toMatchSnapshot"))
    return expectFnCall.args.length !== 1;
  if (expectFnCall.args.length === 2)
    return false;
  const [arg] = expectFnCall.args;
  return !isStringNode(arg);
};
const preferSnapshotHint = createEslintRule({
  name: RULE_NAME$8,
  meta: {
    type: "suggestion",
    docs: {
      description: "Prefer including a hint with external snapshots",
      recommended: "warn"
    },
    messages: {
      missingHint: "You should provide a hint for this snapshot"
    },
    schema: [
      {
        type: "string",
        enum: ["always", "multi"]
      }
    ]
  },
  defaultOptions: ["multi"],
  create(context, [mode]) {
    const snapshotMatchers2 = [];
    let expressionDepth = 0;
    const depths = [];
    const reportSnapshotMatchersWithoutHints = () => {
      for (const snapshotMatcher of snapshotMatchers2) {
        if (isSnapshotMatcherWithoutHint(snapshotMatcher)) {
          context.report({
            messageId: "missingHint",
            node: snapshotMatcher.matcher
          });
        }
      }
    };
    const enterExpression = () => {
      expressionDepth++;
    };
    const exitExpression = () => {
      expressionDepth--;
      if (mode === "always") {
        reportSnapshotMatchersWithoutHints();
        snapshotMatchers2.length = 0;
      }
      if (mode === "multi" && expressionDepth === 0) {
        if (snapshotMatchers2.length > 1)
          reportSnapshotMatchersWithoutHints();
        snapshotMatchers2.length = 0;
      }
    };
    return {
      "Program:exit"() {
        enterExpression();
        exitExpression();
      },
      FunctionExpression: enterExpression,
      "FunctionExpression:exit": exitExpression,
      ArrowFunctionExpression: enterExpression,
      "ArrowFunctionExpression:exit": exitExpression,
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["describe", "test"]))
          expressionDepth = depths.pop() ?? 0;
      },
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect") {
          if (vitestFnCall?.type === "describe" || vitestFnCall?.type === "test") {
            depths.push(expressionDepth);
            expressionDepth = 0;
          }
          return;
        }
        const matcherName = getAccessorValue(vitestFnCall.matcher);
        if (!snapshotMatcherNames.includes(matcherName))
          return;
        snapshotMatchers2.push(vitestFnCall);
      }
    };
  }
});

const RULE_NAME$7 = "valid-describe-callback";
const paramsLocation = (params) => {
  const [first] = params;
  const last = params[params.length - 1];
  return {
    start: first.loc.start,
    end: last.loc.end
  };
};
const validDescribeCallback = createEslintRule({
  name: RULE_NAME$7,
  meta: {
    type: "problem",
    docs: {
      description: "Enforce valid describe callback",
      recommended: "strict"
    },
    messages: {
      nameAndCallback: "Describe requires a name and callback arguments",
      secondArgumentMustBeFunction: "Second argument must be a function",
      noAsyncDescribeCallback: "Describe callback cannot be async",
      unexpectedDescribeArgument: "Unexpected argument in describe callback",
      unexpectedReturnInDescribe: "Unexpected return statement in describe callback"
    },
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "describe")
          return;
        if (node.arguments.length < 1) {
          return context.report({
            messageId: "nameAndCallback",
            loc: node.loc
          });
        }
        const [, callback] = node.arguments;
        if (!callback) {
          context.report({
            messageId: "nameAndCallback",
            loc: paramsLocation(node.arguments)
          });
          return;
        }
        if (!isFunction(callback)) {
          context.report({
            messageId: "secondArgumentMustBeFunction",
            loc: paramsLocation(node.arguments)
          });
          return;
        }
        if (callback.async) {
          context.report({
            messageId: "noAsyncDescribeCallback",
            node: callback
          });
        }
        if (vitestFnCall.members.every((s) => getAccessorValue(s) !== "each") && callback.params.length) {
          context.report({
            messageId: "unexpectedDescribeArgument",
            node: callback
          });
        }
        if (callback.body.type === utils.AST_NODE_TYPES.CallExpression) {
          context.report({
            messageId: "unexpectedReturnInDescribe",
            node: callback
          });
        }
        if (callback.body.type === utils.AST_NODE_TYPES.BlockStatement) {
          callback.body.body.forEach((node2) => {
            if (node2.type === utils.AST_NODE_TYPES.ReturnStatement) {
              context.report({
                messageId: "unexpectedReturnInDescribe",
                node: node2
              });
            }
          });
        }
      }
    };
  }
});

const RULE_NAME$6 = "require-top-level-describe";
const requireTopLevelDescribe = createEslintRule({
  name: RULE_NAME$6,
  meta: {
    docs: {
      description: "Enforce that all tests are in a top-level describe",
      recommended: "warn"
    },
    messages: {
      tooManyDescribes: "There should not be more than {{ max }} describe{{ s }} at the top level",
      unexpectedTestCase: "All test cases must be wrapped in a describe block.",
      unexpectedHook: "All hooks must be wrapped in a describe block."
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          maxNumberOfTopLevelDescribes: {
            type: "number",
            minimum: 1
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [{}],
  create(context) {
    const { maxNumberOfTopLevelDescribes = Infinity } = context.options[0] ?? {};
    let numberOfTopLevelDescribeBlocks = 0;
    let numberOfDescribeBlocks = 0;
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!vitestFnCall)
          return;
        if (vitestFnCall.type === "describe") {
          numberOfDescribeBlocks++;
          if (numberOfDescribeBlocks === 1) {
            numberOfTopLevelDescribeBlocks++;
            if (numberOfTopLevelDescribeBlocks > maxNumberOfTopLevelDescribes) {
              context.report({
                node,
                messageId: "tooManyDescribes",
                data: {
                  max: maxNumberOfTopLevelDescribes,
                  s: maxNumberOfTopLevelDescribes === 1 ? "" : "s"
                }
              });
            }
          }
          return;
        }
        if (numberOfDescribeBlocks === 0) {
          if (vitestFnCall.type === "test") {
            context.report({ node, messageId: "unexpectedTestCase" });
            return;
          }
          if (vitestFnCall.type === "hook")
            context.report({ node, messageId: "unexpectedHook" });
        }
      },
      "CallExpression:exit"(node) {
        if (isTypeOfVitestFnCall(node, context, ["describe"]))
          numberOfDescribeBlocks--;
      }
    };
  }
});

const RULE_NAME$5 = "require-to-throw-message";
const requireToThrowMessage = createEslintRule({
  name: RULE_NAME$5,
  meta: {
    type: "suggestion",
    docs: {
      description: "Require toThrow() to be called with an error message",
      recommended: "warn"
    },
    schema: [],
    messages: {
      addErrorMessage: "Add an error message to {{ matcherName }}()"
    }
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect")
          return;
        const { matcher } = vitestFnCall;
        const matcherName = getAccessorValue(matcher);
        if (vitestFnCall.args.length === 0 && ["toThrow", "toThrowError"].includes(matcherName) && !vitestFnCall.modifiers.some((nod) => getAccessorValue(nod) === "not")) {
          context.report({
            messageId: "addErrorMessage",
            data: { matcherName },
            node: matcher
          });
        }
      }
    };
  }
});

const RULE_NAME$4 = "require-hook";
const isVitestFnCall = (node, context) => {
  if (parseVitestFnCall(node, context))
    return true;
  return !!getNodeName(node)?.startsWith("vi");
};
const isNullOrUndefined = (node) => {
  return node.type === utils.AST_NODE_TYPES.Literal && node.value === null || isIdentifier(node, "undefined");
};
const shouldBeInHook = (node, context, allowedFunctionCalls = []) => {
  switch (node.type) {
    case utils.AST_NODE_TYPES.ExpressionStatement:
      return shouldBeInHook(node.expression, context, allowedFunctionCalls);
    case utils.AST_NODE_TYPES.CallExpression:
      return !(isVitestFnCall(node, context) || allowedFunctionCalls.includes(getNodeName(node)));
    case utils.AST_NODE_TYPES.VariableDeclaration: {
      if (node.kind === "const")
        return false;
      return node.declarations.some(
        ({ init }) => init !== null && !isNullOrUndefined(init)
      );
    }
    default:
      return false;
  }
};
const requireHook = createEslintRule({
  name: RULE_NAME$4,
  meta: {
    docs: {
      description: "Require setup and teardown to be within a hook",
      recommended: "warn"
    },
    messages: {
      useHook: "This should be done within a hook"
    },
    type: "suggestion",
    schema: [
      {
        type: "object",
        properties: {
          allowedFunctionCalls: {
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions: [
    {
      allowedFunctionCalls: []
    }
  ],
  create(context) {
    const { allowedFunctionCalls } = context.options[0] ?? {};
    const checkBlockBody = (body) => {
      for (const statement of body) {
        if (shouldBeInHook(statement, context, allowedFunctionCalls)) {
          context.report({
            node: statement,
            messageId: "useHook"
          });
        }
      }
    };
    return {
      Program(program) {
        checkBlockBody(program.body);
      },
      CallExpression(node) {
        if (!isTypeOfVitestFnCall(node, context, ["describe"]) || node.arguments.length < 2)
          return;
        const [, testFn] = node.arguments;
        if (!isFunction(testFn) || testFn.body.type !== utils.AST_NODE_TYPES.BlockStatement)
          return;
        checkBlockBody(testFn.body.body);
      }
    };
  }
});

const RULE_NAME$3 = "prefer-todo";
const isTargetedTestCase = (vitestFnCall) => {
  if (vitestFnCall.members.some((s) => getAccessorValue(s) !== "skip"))
    return false;
  if (vitestFnCall.name.startsWith("x"))
    return false;
  return !vitestFnCall.name.startsWith("f");
};
function isEmptyFunction(node) {
  if (!isFunction(node))
    return false;
  return node.body.type === utils.AST_NODE_TYPES.BlockStatement && !node.body.body.length;
}
function createTodoFixer(vitestFnCall, fixer) {
  if (vitestFnCall.members.length)
    return replaceAccessorFixer(fixer, vitestFnCall.members[0], "todo");
  return fixer.replaceText(vitestFnCall.head.node, `${vitestFnCall.head.local}.todo`);
}
const preferTodo = createEslintRule({
  name: RULE_NAME$3,
  meta: {
    type: "layout",
    docs: {
      description: "Suggest using `test.todo`",
      recommended: "warn"
    },
    messages: {
      emptyTest: "Prefer todo test case over empty test case",
      unimplementedTest: "Prefer todo test case over unimplemented test case"
    },
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const [title, callback] = node.arguments;
        const vitestFnCall = parseVitestFnCall(node, context);
        if (!title || vitestFnCall?.type !== "test" || !isTargetedTestCase(vitestFnCall) || !isStringNode(title))
          return;
        if (callback && isEmptyFunction(callback)) {
          context.report({
            messageId: "emptyTest",
            node,
            fix: (fixer) => [
              fixer.removeRange([title.range[1], callback.range[1]]),
              createTodoFixer(vitestFnCall, fixer)
            ]
          });
        }
        if (hasOnlyOneArgument(node)) {
          context.report({
            messageId: "unimplementedTest",
            node,
            fix: (fixer) => createTodoFixer(vitestFnCall, fixer)
          });
        }
      }
    };
  }
});

const RULE_NAME$2 = "prefer-spy-on";
const findNodeObject = (node) => {
  if ("object" in node)
    return node.object;
  if (node.callee.type === utils.AST_NODE_TYPES.MemberExpression)
    return node.callee.object;
  return null;
};
const getVitestFnCall = (node) => {
  if (node.type !== utils.AST_NODE_TYPES.CallExpression && node.type !== utils.AST_NODE_TYPES.MemberExpression)
    return null;
  const obj = findNodeObject(node);
  if (!obj)
    return null;
  if (obj.type === utils.AST_NODE_TYPES.Identifier) {
    return node.type === utils.AST_NODE_TYPES.CallExpression && getNodeName(node.callee) === "vi.fn" ? node : null;
  }
  return getVitestFnCall(obj);
};
const getAutoFixMockImplementation = (vitestFnCall, context) => {
  const hasMockImplementationAlready = vitestFnCall.parent?.type === utils.AST_NODE_TYPES.MemberExpression && vitestFnCall.parent.property.type === utils.AST_NODE_TYPES.Identifier && vitestFnCall.parent.property.name === "mockImplementation";
  if (hasMockImplementationAlready)
    return "";
  const [arg] = vitestFnCall.arguments;
  const argSource = arg && context.getSourceCode().getText(arg);
  return argSource ? `.mockImplementation(${argSource})` : ".mockImplementation()";
};
const preferSpyOn = createEslintRule({
  name: RULE_NAME$2,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using `vi.spyOn`",
      recommended: "warn"
    },
    messages: {
      useViSpayOn: "Use `vi.spyOn` instead"
    },
    fixable: "code",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      AssignmentExpression(node) {
        const { left, right } = node;
        if (left.type !== utils.AST_NODE_TYPES.MemberExpression)
          return;
        const vitestFnCall = getVitestFnCall(right);
        if (!vitestFnCall)
          return;
        context.report({
          node,
          messageId: "useViSpayOn",
          fix(fixer) {
            const lefPropQuote = left.property.type === utils.AST_NODE_TYPES.Identifier && !left.computed ? "'" : "";
            const mockImplementation = getAutoFixMockImplementation(vitestFnCall, context);
            return [
              fixer.insertTextBefore(left, "vi.spyOn("),
              fixer.replaceTextRange(
                [left.object.range[1], left.property.range[0]],
                `, ${lefPropQuote}`
              ),
              fixer.replaceTextRange(
                [left.property.range[1], vitestFnCall.range[1]],
                `${lefPropQuote})${mockImplementation}`
              )
            ];
          }
        });
      }
    };
  }
});

const RULE_NAME$1 = "prefer-comparison-matcher";
const isString = (node) => {
  return isStringNode(node) || node?.type === utils.AST_NODE_TYPES.TemplateLiteral;
};
const isComparingToString = (expression) => {
  return isString(expression.left) || isString(expression.right);
};
const invertOperator = (operator) => {
  switch (operator) {
    case ">":
      return "<=";
    case "<":
      return ">=";
    case ">=":
      return "<";
    case "<=":
      return ">";
  }
  return null;
};
const determineMatcher = (operator, negated) => {
  const op = negated ? invertOperator(operator) : operator;
  switch (op) {
    case ">":
      return "toBeGreaterThan";
    case "<":
      return "toBeLessThan";
    case ">=":
      return "toBeGreaterThanOrEqual";
    case "<=":
      return "toBeLessThanOrEqual";
  }
  return null;
};
const preferComparisonMatcher = createEslintRule({
  name: RULE_NAME$1,
  meta: {
    type: "suggestion",
    docs: {
      description: "Suggest using the built-in comparison matchers",
      recommended: "error"
    },
    schema: [],
    fixable: "code",
    messages: {
      useToBeComparison: "Prefer using `{{ preferredMatcher }}` instead"
    }
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect" || vitestFnCall.args.length === 0)
          return;
        const { parent: expect } = vitestFnCall.head.node;
        if (expect?.type !== utils.AST_NODE_TYPES.CallExpression)
          return;
        const {
          arguments: [comparison],
          range: [, expectCallEnd]
        } = expect;
        const { matcher } = vitestFnCall;
        const matcherArg = getFirstMatcherArg(vitestFnCall);
        if (comparison?.type !== utils.AST_NODE_TYPES.BinaryExpression || isComparingToString(comparison) || // eslint-disable-next-line no-prototype-builtins
        !EqualityMatcher.hasOwnProperty(getAccessorValue(matcher)) || !isBooleanLiteral(matcherArg))
          return;
        const [modifier] = vitestFnCall.modifiers;
        const hasNot = vitestFnCall.modifiers.some((nod) => getAccessorValue(nod) === "not");
        const preferredMatcher = determineMatcher(comparison.operator, matcherArg.value === hasNot);
        if (!preferredMatcher)
          return;
        context.report({
          fix(fixer) {
            const sourceCode = context.getSourceCode();
            const modifierText = modifier && getAccessorValue(modifier) !== "not" ? `.${getAccessorValue(modifier)}` : "";
            return [
              fixer.replaceText(
                comparison,
                sourceCode.getText(comparison.left)
              ),
              fixer.replaceTextRange(
                [expectCallEnd, matcher.parent.range[1]],
                `${modifierText}.${preferredMatcher}`
              ),
              fixer.replaceText(
                matcherArg,
                sourceCode.getText(comparison.right)
              )
            ];
          },
          messageId: "useToBeComparison",
          data: { preferredMatcher },
          node: matcher
        });
      }
    };
  }
});

const RULE_NAME = "prefer-to-contain";
const isFixableIncludesCallExpression = (node) => node.type === utils.AST_NODE_TYPES.CallExpression && node.callee.type === utils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.callee.property, "includes") && hasOnlyOneArgument(node) && node.arguments[0].type !== utils.AST_NODE_TYPES.SpreadElement;
const preferToContain = createEslintRule({
  name: RULE_NAME,
  meta: {
    docs: {
      description: "Prefer using toContain()",
      recommended: "warn"
    },
    messages: {
      useToContain: "Use toContain() instead"
    },
    fixable: "code",
    type: "suggestion",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const vitestFnCall = parseVitestFnCall(node, context);
        if (vitestFnCall?.type !== "expect" || vitestFnCall.args.length === 0)
          return;
        const { parent: expect } = vitestFnCall.head.node;
        if (expect?.type !== utils.AST_NODE_TYPES.CallExpression)
          return;
        const {
          arguments: [includesCall],
          range: [, expectCallEnd]
        } = expect;
        const { matcher } = vitestFnCall;
        const matcherArg = getFirstMatcherArg(vitestFnCall);
        if (!includesCall || matcherArg.type === utils.AST_NODE_TYPES.SpreadElement || // eslint-disable-next-line no-prototype-builtins
        !EqualityMatcher.hasOwnProperty(getAccessorValue(matcher)) || !isBooleanLiteral(matcherArg) || !isFixableIncludesCallExpression(includesCall))
          return;
        const hasNot = vitestFnCall.modifiers.some((nod) => getAccessorValue(nod) === "not");
        context.report({
          fix(fixer) {
            const sourceCode = context.getSourceCode();
            const addNotModifier = matcherArg.value === hasNot;
            return [
              fixer.removeRange([
                includesCall.callee.property.range[0] - 1,
                includesCall.range[1]
              ]),
              fixer.replaceTextRange(
                [expectCallEnd, matcher.parent.range[1]],
                addNotModifier ? `.${ModifierName.not}.toContain` : ".toContain"
              ),
              fixer.replaceText(
                vitestFnCall.args[0],
                sourceCode.getText(includesCall.arguments[0])
              )
            ];
          },
          messageId: "useToContain",
          node: matcher
        });
      }
    };
  }
});

const createConfig = (rules) => ({
  plugins: ["vitest"],
  rules: Object.keys(rules).reduce((acc, ruleName) => {
    return {
      ...acc,
      [`vitest/${ruleName}`]: rules[ruleName]
    };
  }, {})
});
const allRules = {
  [RULE_NAME$M]: "warn",
  [RULE_NAME$L]: "warn",
  [RULE_NAME$J]: "warn",
  [RULE_NAME$I]: "warn",
  [RULE_NAME$G]: "warn",
  [RULE_NAME$E]: "warn",
  [RULE_NAME$D]: "warn",
  [RULE_NAME$C]: "warn",
  [RULE_NAME$B]: "warn",
  [RULE_NAME$A]: "warn",
  [RULE_NAME$y]: "warn",
  [RULE_NAME$x]: "warn",
  [RULE_NAME$w]: "warn",
  [RULE_NAME$v]: "warn",
  [RULE_NAME$u]: "warn",
  [RULE_NAME$t]: "warn",
  [RULE_NAME$s]: "warn",
  [RULE_NAME$r]: "warn",
  [RULE_NAME$q]: "warn",
  [RULE_NAME$p]: "warn",
  [RULE_NAME$o]: "warn",
  [RULE_NAME$n]: "warn",
  [RULE_NAME$m]: "warn",
  [RULE_NAME$h]: "warn",
  [RULE_NAME$j]: "warn",
  [RULE_NAME$i]: "warn",
  [RULE_NAME$g]: "warn",
  [RULE_NAME$f]: "warn",
  [RULE_NAME$e]: "warn",
  [RULE_NAME$d]: "warn",
  [RULE_NAME$c]: "warn",
  [RULE_NAME$b]: "warn",
  [RULE_NAME$a]: "warn",
  [RULE_NAME$9]: "warn",
  [RULE_NAME$8]: "warn",
  [RULE_NAME$6]: "warn",
  [RULE_NAME$5]: "warn",
  [RULE_NAME$4]: "warn",
  [RULE_NAME$3]: "warn",
  [RULE_NAME$2]: "warn",
  [RULE_NAME$3]: "warn",
  [RULE_NAME$1]: "warn",
  [RULE_NAME]: "warn"
};
const recommended = {
  [RULE_NAME$H]: "warn",
  [RULE_NAME$K]: "warn",
  [RULE_NAME$F]: "warn",
  [RULE_NAME$z]: "warn",
  [RULE_NAME$l]: "warn",
  [RULE_NAME$k]: "warn",
  [RULE_NAME$7]: "warn"
};
const index = {
  rules: {
    [RULE_NAME$M]: lowerCaseTitle,
    [RULE_NAME$L]: maxNestedDescribe,
    [RULE_NAME$K]: noIdenticalTitle,
    [RULE_NAME$J]: noFocusedTests,
    [RULE_NAME$I]: noConditionalTest,
    [RULE_NAME$H]: expectExpect,
    [RULE_NAME$G]: consistentTestIt,
    [RULE_NAME$F]: preferToBe,
    [RULE_NAME$E]: noHooks,
    [RULE_NAME$D]: noRestrictedViMethods,
    [RULE_NAME$C]: consistentTestFilename,
    [RULE_NAME$B]: maxExpect,
    [RULE_NAME$A]: noAliasMethod,
    [RULE_NAME$z]: noCommentedOutTests,
    [RULE_NAME$y]: noConditonalExpect,
    [RULE_NAME$x]: noConditionalInTest,
    [RULE_NAME$w]: noDisabledTests,
    [RULE_NAME$v]: noDoneCallback,
    [RULE_NAME$u]: noDuplicateHooks,
    [RULE_NAME$t]: noLargeSnapshots,
    [RULE_NAME$s]: nonInterpolationInSnapShots,
    [RULE_NAME$r]: noMocksImport,
    [RULE_NAME$q]: noRestrictedMatchers,
    [RULE_NAME$p]: noStandaloneExpect,
    [RULE_NAME$o]: noTestPrefixes,
    [RULE_NAME$n]: noTestReturnStatement,
    [RULE_NAME$m]: preferCalledWith,
    [RULE_NAME$l]: validTitle,
    [RULE_NAME$k]: validExpect,
    [RULE_NAME$h]: preferToBeFalsy,
    [RULE_NAME$j]: preferToBeObject,
    [RULE_NAME$i]: preferToBeTruthy,
    [RULE_NAME$g]: preferToHaveLength,
    [RULE_NAME$f]: preferEqualityMatcher,
    [RULE_NAME$e]: preferStrictEqual,
    [RULE_NAME$d]: preferExpectResolves,
    [RULE_NAME$c]: preferEach,
    [RULE_NAME$b]: preferHooksOnTop,
    [RULE_NAME$a]: preferHooksInOrder,
    [RULE_NAME$9]: preferMockPromiseShorthand,
    [RULE_NAME$8]: preferSnapshotHint,
    [RULE_NAME$7]: validDescribeCallback,
    [RULE_NAME$6]: requireTopLevelDescribe,
    [RULE_NAME$5]: requireToThrowMessage,
    [RULE_NAME$4]: requireHook,
    [RULE_NAME$3]: preferTodo,
    [RULE_NAME$2]: preferSpyOn,
    [RULE_NAME$3]: preferTodo,
    [RULE_NAME$1]: preferComparisonMatcher,
    [RULE_NAME]: preferToContain
  },
  configs: {
    all: createConfig(allRules),
    recommended: createConfig(recommended)
  },
  environments: {
    env: {
      globals: {
        suite: true,
        test: true,
        describe: true,
        it: true,
        expect: true,
        assert: true,
        vitest: true,
        vi: true,
        beforeAll: true,
        afterAll: true,
        beforeEach: true,
        afterEach: true
      }
    }
  }
};

module.exports = index;
