{"version":3,"file":"signals.module.js","sources":["../src/index.ts"],"sourcesContent":["import { options, Component } from \"preact\";\nimport { useRef, useMemo, useEffect } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport { signal, computed, batch, effect, Signal, type ReadonlySignal };\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction Text(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst s = useMemo(() => {\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Replace this component's vdom updater with a direct text one:\n\t\tthis._updater!._callback = () => {\n\t\t\t(this.base as Text).data = s.peek();\n\t\t};\n\n\t\treturn computed(() => {\n\t\t\tlet data = currentSignal.value;\n\t\t\tlet s = data.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\t}, []);\n\n\treturn s.value;\n}\nText.displayName = \"_st\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true, value: undefined },\n\ttype: { configurable: true, value: Text },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tsetCurrentUpdater();\n\n\tlet updater;\n\n\tlet component = vnode.__c;\n\tif (component) {\n\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\tupdater = component._updater;\n\t\tif (updater === undefined) {\n\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tcomponent.setState({});\n\t\t\t});\n\t\t}\n\t}\n\n\tcurrentComponent = component;\n\tsetCurrentUpdater(updater);\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(() => {\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// let reason;\n\t// if (!hasSignals && !hasComputeds.has(this)) {\n\t// \treason = \"no signals or computeds\";\n\t// } else if (hasPendingUpdate.has(this)) {\n\t// \treason = \"has pending update\";\n\t// } else if (hasHookState.has(this)) {\n\t// \treason = \"has hook state\";\n\t// }\n\t// if (reason) {\n\t// \tif (!this) reason += \" (`this` bug)\";\n\t// \tconsole.log(\"not optimizing\", this?.constructor?.name, \": \", reason, {\n\t// \t\tdetails: {\n\t// \t\t\thasSignals,\n\t// \t\t\thasComputeds: hasComputeds.has(this),\n\t// \t\t\thasPendingUpdate: hasPendingUpdate.has(this),\n\t// \t\t\thasHookState: hasHookState.has(this),\n\t// \t\t\tdeps: Array.from(updater._deps),\n\t// \t\t\tupdater,\n\t// \t\t},\n\t// \t});\n\t// }\n\n\t// if this component used no signals or computeds, update:\n\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t// if there is a pending re-render triggered from Signals,\n\t// or if there is hook or class state, update:\n\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), []);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\treturn useMemo(() => computed<T>(() => $compute.current()), []);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n"],"names":["Component","options","useMemo","useRef","useEffect","Signal","computed","signal","effect","batch","currentComponent","hook","hookName","hookFn","bind","setCurrentUpdater","updater","finishUpdate","_start","Text","_ref","data","currentSignal","useSignal","value","s","v","_this","__v","__","__c","_updateFlags","_updater","_callback","base","peek","displayName","Object","defineProperties","prototype","constructor","configurable","undefined","type","props","get","this","__b","old","vnode","i","signalProps","__np","component","update","setState","createUpdater","error","oldVNode","dom","__e","renderedProps","_updaters","updaters","prop","_dispose","_signal","createPropUpdater","_update","propSignal","setAsProperty","ownerSVGElement","changeSignal","newSignal","newProps","setAttribute","removeAttribute","_updater2","index","shouldComponentUpdate","state","_sources","HAS_PENDING_UPDATE","_i","useComputed","compute","$compute","current","useSignalEffect","cb","callback"],"mappings":"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"}